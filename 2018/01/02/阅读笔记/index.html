<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>阅读笔记 | 湖心亭看雪</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="以下均为阅读文章所总结及复制 从Chrome源码看DNS解析过程 2018-1-2当一台设备连接到路由器后，会发送DHCP Request的广播，然后会为电脑分配IP地址及DNS服务器地址nameserver。 Chrome会按照nameservers的顺序发起查询，并将结果缓存下来，有效时间是根据域名设置的TTL决定，在有效期内可以根据结果查询。缓存-&amp;gt;本地host文件(Chrome以Ma">
<meta property="og:type" content="article">
<meta property="og:title" content="阅读笔记">
<meta property="og:url" content="http://yoursite.com/2018/01/02/阅读笔记/index.html">
<meta property="og:site_name" content="湖心亭看雪">
<meta property="og:description" content="以下均为阅读文章所总结及复制 从Chrome源码看DNS解析过程 2018-1-2当一台设备连接到路由器后，会发送DHCP Request的广播，然后会为电脑分配IP地址及DNS服务器地址nameserver。 Chrome会按照nameservers的顺序发起查询，并将结果缓存下来，有效时间是根据域名设置的TTL决定，在有效期内可以根据结果查询。缓存-&amp;gt;本地host文件(Chrome以Ma">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/90068090.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/76791019.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/20543836.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/5961679.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/61189215.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-8/58541315.jpg">
<meta property="og:updated_time" content="2018-01-08T14:59:20.369Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阅读笔记">
<meta name="twitter:description" content="以下均为阅读文章所总结及复制 从Chrome源码看DNS解析过程 2018-1-2当一台设备连接到路由器后，会发送DHCP Request的广播，然后会为电脑分配IP地址及DNS服务器地址nameserver。 Chrome会按照nameservers的顺序发起查询，并将结果缓存下来，有效时间是根据域名设置的TTL决定，在有效期内可以根据结果查询。缓存-&amp;gt;本地host文件(Chrome以Ma">
<meta name="twitter:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/90068090.jpg">
  
    <link rel="alternate" href="/atom.xml" title="湖心亭看雪" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">湖心亭看雪</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-阅读笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/02/阅读笔记/" class="article-date">
  <time datetime="2018-01-02T03:04:50.000Z" itemprop="datePublished">2018-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      阅读笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下均为阅读文章所总结及复制</p>
<h2 id="从Chrome源码看DNS解析过程-2018-1-2"><a href="#从Chrome源码看DNS解析过程-2018-1-2" class="headerlink" title="从Chrome源码看DNS解析过程 2018-1-2"></a>从Chrome源码看DNS解析过程 2018-1-2</h2><p>当一台设备连接到路由器后，会发送DHCP Request的广播，然后会为电脑分配IP地址及DNS服务器地址nameserver。</p>
<p>Chrome会按照nameservers的顺序发起查询，并将结果缓存下来，有效时间是根据域名设置的TTL决定，在有效期内可以根据结果查询。<br>缓存-&gt;本地host文件(Chrome以Map形式保存host)-&gt;nameserver查询。</p>
<p>A - 把域名解析到一个IPV4地址上<br>AAAA - 把域名解析到一个IPV6地址上<br>CNAME - 解析到另外一个域名(当很多其它域名指向一个CNAME时，当需要改变IP地址时，只要改变这个CNAME的地址，那么其它的也跟着生效了，但是得做二次解析。)</p>
<h2 id="缓存穿透、缓存并发、缓存失效之思路变迁"><a href="#缓存穿透、缓存并发、缓存失效之思路变迁" class="headerlink" title="缓存穿透、缓存并发、缓存失效之思路变迁"></a>缓存穿透、缓存并发、缓存失效之思路变迁</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB,如果大量请求(缓存不存在),导致 <strong>缓存穿透</strong> ,DB可能挂掉。</p>
<p>解决方法：<br>可以将这个不存在的key预先设定一个值。避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。</p>
<h3 id="缓存并发"><a href="#缓存并发" class="headerlink" title="缓存并发"></a>缓存并发</h3><p>一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。</p>
<p>解决方法：<br>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁。其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</p>
<h3 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h3><p>在同一时间，出现多个缓存失效。</p>
<p>解决方法：<br>缓存失效时间分散开来。</p>
<h2 id="面向GC的JAVA编程-2018-1-3"><a href="#面向GC的JAVA编程-2018-1-3" class="headerlink" title="面向GC的JAVA编程 2018-1-3"></a>面向GC的JAVA编程 2018-1-3</h2><p>(1)不要使用<code>Thread.yield()</code>和<code>System.gc()</code>(除非你真的需要回收Native Memory)</p>
<p>(2)如果可以的话，请指定容器初始化大小。</p>
<p>(3)如果可以在方法内声明的局部变量，就不要声明为实例变量。</p>
<p>(4)除非你的对象是单例的或不变的，否则尽可能少地声明static变量。不然，会一直留在内存里。</p>
<p>(5)引用</p>
<ul>
<li>Strong Reference，最常见的引用</li>
<li>Weak Reference，当没有指向它的强引用时会被GC回收</li>
<li>Soft Reference，只当临近OOM时才会被GC回收</li>
<li>Phantom Reference，主要用于识别对象被GC的时机，通常用于做一些清理工作</li>
</ul>
<h2 id="从LONGADDER看更高效的无锁实现"><a href="#从LONGADDER看更高效的无锁实现" class="headerlink" title="从LONGADDER看更高效的无锁实现"></a>从LONGADDER看更高效的无锁实现</h2><p><code>AtomicLong</code>的实现方式是内部有个value 变量，当多线程并发自增，自减时，均通过CAS 指令从机器指令级别操作保证并发的原子性。</p>
<p><code>LongAddr</code>解决办法是：减少并发，将单一value的更新压力分担到多个value中去，降低单个value的 “热度”，分段更新，最后将Value相加。先使用CAS进行更新，如果不成功再执行上面的操作。将Value放在Cells数组里。</p>
<h2 id="四个流行的JAVA连接池-2018-1-4"><a href="#四个流行的JAVA连接池-2018-1-4" class="headerlink" title="四个流行的JAVA连接池 2018-1-4"></a>四个流行的JAVA连接池 2018-1-4</h2><p>(1)C3P0是一个开放源代码的JDBC连接池。它实现了数据源和JNDI绑定，使用它的开源项目有Hibernate，Spring等。c3p0有自动回收空闲连接的功能，提供了最大空闲时间。当超过最大空闲时间，连接会断开。</p>
<p>(2)DBCP(Database Connection Pool)是一个依赖Jakarta commons-pool对象池机制的数据库连接池，Tomcat的数据源使用的就是DBCP。不提供回收空闲连接功能,DBCP提供最大连接数。当连接数超过max，所有连接都会断开。</p>
<p>(3)BoneCP 是一个开源的快速的 JDBC 连接池。</p>
<p>(4)Proxool是一个Java SQL Driver驱动程序，提供了对你选择的其它类型的驱动程序的连接池封装。可以非常简单的移植到现存的代码中。完全可配置。快速，成熟，健壮。</p>
<h2 id="彻底理解事务的4个隔离级别"><a href="#彻底理解事务的4个隔离级别" class="headerlink" title="彻底理解事务的4个隔离级别"></a>彻底理解事务的4个隔离级别</h2><p>事务保证，要么全部执行，要么都不执行，从一个状态转变到另一个状态。<br>事务的隔离级别有4种，由低到高一依次为Read uncommitted、Read committed、Repeatable read、Serializable。<br>这些级别可以解决，脏读、不可重复度、幻读。</p>
<h3 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h3><p>一个事务可以读取另一个未提交事务的数据。可出现脏读。</p>
<h3 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h3><p>一个事务要等另一个事务提交后才能读取数据。可出现不可重复度，解决脏读。</p>
<h3 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h3><p>开始读取数据（事务开启）时，不再允许修改操作。出现幻读，解决不可重复读。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>事务串行化顺序执行，可以避免脏读、不可重复读与幻读。</p>
<h3 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h3><p>原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）</p>
<p>原子性：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。<br>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。<br>隔离性：一个事务的执行不能其它事务干扰。<br>持续性：个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。</p>
<p>改变MySQL隔离级别的方法：<br><code>set session transaction Isolation level read uncommitted</code></p>
<h2 id="Spring核心系列之ApplicationContext-2018-1-6"><a href="#Spring核心系列之ApplicationContext-2018-1-6" class="headerlink" title="Spring核心系列之ApplicationContext 2018-1-6"></a>Spring核心系列之ApplicationContext 2018-1-6</h2><h3 id="Spring中的Resource接口"><a href="#Spring中的Resource接口" class="headerlink" title="Spring中的Resource接口"></a>Spring中的Resource接口</h3><p>Resource接口是Spring提供的，它为应用提供了更强的底层资源访问能力。</p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/90068090.jpg" alt=""></p>
<ul>
<li>ClassPathResource: 以类路径为相对路劲下的资源。</li>
<li>FileSystemResource : 以文件系统路径查找的资源。</li>
<li>ServletContextResource : 以相对于Web应用跟目录的方式访问。</li>
<li>ByteArrayResource: 二进制数组表示的资源。</li>
</ul>
<p>加载Spring下的配置文件<br><code>Resource res =new ServletContectResource(/WEB-INF/classes/spring/application.xml);</code></p>
<p>Spring资源地址表达式<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/76791019.jpg" alt=""></p>
<ul>
<li>?:匹配文件名中的一个字符.</li>
<li>*:匹配文件命中的任意字符.</li>
<li>** :匹配多层路径.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class GaoshiApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">		PathMatchingResourcePatternResolver resolver=new PathMatchingResourcePatternResolver();</span><br><span class="line">		Resource[] res =resolver.getResources(&quot;file:/Users/zdy/Desktop/sql.txt&quot;);</span><br><span class="line">		for (Resource  resource : res)&#123;</span><br><span class="line">			System.out.println(resource.getDescription()+&quot;----&quot;+resource.getFilename());</span><br><span class="line">		&#125;</span><br><span class="line">		SpringApplication.run(GaoshiApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">URL [file:/Users/zdy/Desktop/sql.txt]----sql.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h3><p>ApplicationContext继承自BeanFactory，提供的功能更加强大，一般情况下都是使用ApplicationContext。</p>
<p>ApplicationContext也就是我们说的Spring容器。</p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/20543836.jpg" alt=""></p>
<ul>
<li>ApplicationEventPublisher: 让容器拥有发布应用程序上下文事件的功能.</li>
<li>ResourcePatternResolver:实现了类似于资源加载器的功能，能够识别特定前缀加Ant风格的路径并加载到容器中.</li>
<li>LifeCycle：管理容器中bean的生命周期。</li>
<li>ConfigurableApplicationContext:主要新增了refresh()和close()方法，让ApplicationContext有用了启动，关系和刷新上下文的功能。</li>
<li><strong>ClassPathXmlApplicationContext与FileSystemXmlApplicationContext</strong>:Spring提供的两个常用的ApplicationContext实现类，前者默认从类路径加载配置文件，后者从文件系统加载。<br>然后初始化一个ApplicationContext看看:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac =new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class="line">ApplicationContext ac =new FileSystemXmlApplicationContext(/User/Desktop/application.xml);</span><br></pre></td></tr></table></figure>
<p>ClassPathXmlApplicationContext如果没有前缀默认就是classpath:</p>
<p>FileSystemXmlApplicationContext如果没有前缀默认就是 file:</p>
<p>WebApplicationContext与ServletContext可以相互获得.在非Web应用的环境下，Bean只有singleton和prototype两种作用域，而WebApplicationContext为Bean添加了三个新的作用域:request,session,global session。</p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/5961679.jpg" alt=""></p>
<p>XmlWebApplicationContext和AnnotationConfigWebApplicationContext，大家猜都应该猜到了，一个是XML配置的，一个是<code>@Configuration</code>配置的。</p>
<p>WebApplicationContext和ServletContext相互获取</p>
<p><strong>WebApplicationContext里有ServletContext成员变量，直接get就完了。在ServletContext里有一个写死的attrbute，也是直接get..而且Spring提供了一个WebApplicationContextUtils来封装了这个写死的attribute.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其实就是直接调用了</span><br><span class="line">ServletContext.getAttribute(ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123;</span><br><span class="line">        return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/61189215.jpg" alt=""></p>
<h2 id="JAVA的字符串拼接与性能"><a href="#JAVA的字符串拼接与性能" class="headerlink" title="JAVA的字符串拼接与性能"></a>JAVA的字符串拼接与性能</h2><p>观察String的<code>concat()</code>反编译出来的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">46:  new #6; //class java/lang/StringBuilder</span><br><span class="line">49:  dup</span><br><span class="line">50:  invokespecial   #7; //Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">53:  aload_1</span><br><span class="line">54:  invokevirtual   #8; //Method java/lang/StringBuilder.append:</span><br><span class="line">         (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">57:  ldc #9; //String *</span><br><span class="line">59:  invokevirtual   #8; //Method java/lang/StringBuilder.append:</span><br><span class="line">         (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">62:  invokevirtual   #10; //Method java/lang/StringBuilder.toString:()</span><br><span class="line">         Ljava/lang/String;</span><br><span class="line">65:  astore_1</span><br><span class="line">66:  iinc    7, 1</span><br><span class="line">69:  goto    38</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>concat()</code>方法使用的是StringBuilder,性能和StringBuilder一样，但是由于额外的创建StringBuilder对象和执行<code>.append(str).append(str).toString</code>导致性能稍弱于StringBuilder。</p>
<p><strong>在不考虑线程安全和同步的情况下，为了获得最高的性能，我们应尽量使用StringBuilder</strong></p>
<h2 id="JAVA构造时成员初始化的陷阱-2018-1-7"><a href="#JAVA构造时成员初始化的陷阱-2018-1-7" class="headerlink" title="JAVA构造时成员初始化的陷阱 2018-1-7"></a>JAVA构造时成员初始化的陷阱 2018-1-7</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//基类</span><br><span class="line">public class Base</span><br><span class="line">&#123;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        preProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void preProcess() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Derived extends Base</span><br><span class="line">&#123;</span><br><span class="line">    public String whenAmISet = &quot;set when declared&quot;;</span><br><span class="line"></span><br><span class="line">    @Override void preProcess()</span><br><span class="line">    &#123;</span><br><span class="line">        whenAmISet = &quot;set in preProcess()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Derived d = new Derived();</span><br><span class="line">        System.out.println( d.whenAmISet );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此，打印的结果是:<code>set when declared</code></p>
<p>运行流程:</p>
<ol>
<li>进入Derived 构造函数。</li>
<li>Derived 成员变量的内存被分配。</li>
<li>Base 构造函数被隐含调用。</li>
<li>Base 构造函数调用preProcess()。</li>
<li>Derived 的preProcess 设置whenAmISet 值为 “set in preProcess()”。</li>
<li>Derived 的成员变量初始化被调用。</li>
<li>执行Derived 构造函数体。</li>
</ol>
<p><strong>我们的错误就在于我们把Java中的声明和初始化看成了一体。</strong></p>
<p><strong>在C++的世界中，C++并不支持成员变量在声明的时候进行初始化，其需要你在构造函数中显式的初始化其成员变量的值，看起来很土，但其实C++用心良苦。</strong></p>
<p>JAVA：如果调用的是子类的函数的话，这可能产生问题的：因为在构造子类对象的时候，首先调用父类的构造函数，而这时候如果去调用子类的函数，由于子类还没有构造完成，子类的成员尚未初始化，这么做显然是不安全的。</p>
<h2 id="深入理解Java-try-with-resource"><a href="#深入理解Java-try-with-resource" class="headerlink" title="深入理解Java try-with-resource"></a>深入理解Java try-with-resource</h2><p>所有打开的系统资源，比如流、文件或者Socket连接等，都需要被开发者手动关闭，否则随着程序的不断运行，资源泄露将会累积成重大的生产事故。</p>
<p>我们使用jdk1.7里新增的try-with-resource语法糖来打开资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;)));</span><br><span class="line">             BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123;</span><br><span class="line">            int b;</span><br><span class="line">            while ((b = bin.read()) != -1) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>动手实践:<br>为了能够配合try-with-resource，资源必须实现AutoClosable接口。该接口的实现类需要重写close方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Connection implements AutoCloseable &#123;</span><br><span class="line">    public void sendData() &#123;</span><br><span class="line">        System.out.println(&quot;正在发送数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;正在关闭连接&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (Connection conn = new Connection()) &#123;</span><br><span class="line">            conn.sendData();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:  close自动被调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正在发送数据</span><br><span class="line">正在关闭连接</span><br></pre></td></tr></table></figure></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>编译器自动帮我们生成了finally块，并且在里面调用了资源的close方法，所以例子中的close方法会在运行的时候被执行。</p>
<p>编译器生成finally代码之外还在里头生成了<code>addSuppressed()</code>方法,他支持将一个异常附加到另一个异常身上，从而避免异常屏蔽。保证close如果抛出异常，不会被屏蔽掉。</p>
<h2 id="Git远程操作详解-2018-1-8"><a href="#Git远程操作详解-2018-1-8" class="headerlink" title="Git远程操作详解 2018-1-8"></a>Git远程操作详解 2018-1-8</h2><p>Git常用命令：</p>
<ul>
<li>git clone</li>
<li>git remote</li>
<li>git fetch</li>
<li>git pull</li>
<li>git push</li>
</ul>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-8/58541315.jpg" alt=""></p>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;版本库的网址&gt;</span><br><span class="line"></span><br><span class="line">$ git clone https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。<br><code>git remote</code> 列出所有远程主机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<p>克隆的时候，指定远程主机叫做jQuery。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -o jQuery https://github.com/jquery/jquery.git</span><br><span class="line">$ git remote</span><br><span class="line">jQuery</span><br></pre></td></tr></table></figure></p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>一旦远程主机remote有了更新(Git术语叫commit)，需要将这些更新取回本地，这时需要<code>git fetch</code>命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将某个远程主机的更新，全部取回本地。</span><br><span class="line">$ git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。<br>默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">取回特定分支的更新，可以指定分支名。</span><br><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line">取回origin主机的master分支</span><br><span class="line">$ git fetch origin master</span><br></pre></td></tr></table></figure></p>
<p><code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure></p>
<p>本地分支<code>master</code>,远程分支<code>origin/master</code>.</p>
<p><code>git checkout</code>创建一个新的分支。</p>
<p>在<code>orign/master</code>基础上，创建一个新分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure></p>
<p>然后可以使用<code>git merge</code>或<code>git rebase</code>命令，将本地分支合并到远程分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line"># 或者   合并到origin/master上</span><br><span class="line">$ git rebase origin/master</span><br></pre></td></tr></table></figure></p>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code>，取回远程主机某个分支的更新，再与本地的指定分支合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
<p>比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin next:master</span><br></pre></td></tr></table></figure></p>
<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<p>面试爱问的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin next</span><br></pre></td></tr></table></figure></p>
<p>解释：拉去远程origin/next分支，然后在本地分支和它合并。<br>和下面代码功能相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">$ git merge origin/next</span><br></pre></td></tr></table></figure></p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><code>git push</code>用于将本地分支的更新，推送到远程主机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="AWK使用"><a href="#AWK使用" class="headerlink" title="AWK使用"></a>AWK使用</h2><p>AWK:是一个行文本处理工具。它是逐行处理文件中的数据。<br>语法:<code>awk &#39;pattern+{action}&#39;</code><br>解释:<br>(1)大括号<code>{}</code>表示为一个命令分组。<br>(2)pattern是过滤器，pattern成功的才能执行action动作。</p>
<p>实例:显示<code>hello.txt</code>第三行到第六行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | awk &apos;NR==3, NR==6&#123;print;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p>FS：分隔符，默认是空格<br>NR： 当前行数，从1开始<br>NF： 当前记录字段个数<br>$0： 当前记录<br>$1~$n: 当前记录第n个字段<br>例子：显示hello.txt中的第3行至第5行的第一列与最后一列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | awk &apos;NR==3, NR==5&#123;print $1,$NF&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h3><p>pattern参数可以是egrep正则中的一个，正则使用<code>/pattern/</code><br>例子：显示WiFi_Log.txt中，正则匹配pid的行<br><code>cat WiFi_Log.txt | awk &#39;/pid/&#39;</code></p>
<ol>
<li>pattern和action可以只有其一，但不能两者都没有；</li>
<li>默认的action是print</li>
</ol>
<p>例子：显示hello.txt中，长度大于100的行号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | awk &apos;length($0)&gt;80&#123;print NR&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><ul>
<li>gsub(r,s)：在$0中用s代替r</li>
<li>index(s,t)：返回s中t的第一个位置</li>
<li>length(s)：s的长度</li>
<li>match(s,r)：s是否匹配r</li>
<li>split(s,a,fs)：在fs上将s分成序列a</li>
<li>substr(s,p)：返回s从p开始的子串</li>
</ul>
<h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>BEGIN和END本质是一个pattern。<br>BEGIN用于awk程序开始开始前，做一些初始化的工作；<br>END用于awk程序结束前，做一些收尾的工作。</p>
<p>例子：统计字符个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;</span><br><span class="line">BEGIN</span><br><span class="line">&#123;</span><br><span class="line">count=0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">count+=length($0);</span><br><span class="line">&#125;</span><br><span class="line">END</span><br><span class="line">&#123;</span><br><span class="line">print count;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>流程控制语句 (和java、c、c++一样)<br>（1）if(condition){}else{}<br>（2）while{}<br>（3）do{}while(condition);<br>（4）for(init;condition;step){}<br>（5）break/continue：如果有END，会执行END中的收尾工作</p>
<h3 id="awk与shell交互"><a href="#awk与shell交互" class="headerlink" title="awk与shell交互"></a>awk与shell交互</h3><p>(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">STR=&quot;hello&quot;</span><br><span class="line">echo | awk &apos;&#123;</span><br><span class="line">print &quot;&apos;$&#123;STR&#125;&apos;&quot;;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果： 打印 hello</span><br></pre></td></tr></table></figure>
<p>(2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo hello | awk &apos;&#123;</span><br><span class="line">print $0 | &quot;cat&quot;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：打印 hello  如果没有echo 则 执行cat命令</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/02/阅读笔记/" data-id="cjc3eisuf0007lgvallj7758c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/01/06/Python入门学习(三)-变量与运算符/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Python入门学习(三)-变量与运算符
        
      </div>
    </a>
  
  
    <a href="/2018/01/01/2018年实施计划/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2018年实施计划</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java多线程/">Java多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python基础/">Python基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/06/Python入门学习(三)-变量与运算符/">Python入门学习(三)-变量与运算符</a>
          </li>
        
          <li>
            <a href="/2018/01/02/阅读笔记/">阅读笔记</a>
          </li>
        
          <li>
            <a href="/2018/01/01/2018年实施计划/">2018年实施计划</a>
          </li>
        
          <li>
            <a href="/2017/12/29/JAVA反射/">JAVA反射</a>
          </li>
        
          <li>
            <a href="/2017/12/28/Lock的使用/">Lock的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 殷鑫<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>