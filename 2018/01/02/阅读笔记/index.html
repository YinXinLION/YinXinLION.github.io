<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>阅读笔记 | 湖心亭看雪</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="以下均为阅读文章所搬运及少部分总结的。 =-= 大自然的搬运工。。 从Chrome源码看DNS解析过程 2018-1-2当一台设备连接到路由器后，会发送DHCP Request的广播，然后会为电脑分配IP地址及DNS服务器地址nameserver。 Chrome会按照nameservers的顺序发起查询，并将结果缓存下来，有效时间是根据域名设置的TTL决定，在有效期内可以根据结果查询。缓存-&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="阅读笔记">
<meta property="og:url" content="http://yoursite.com/2018/01/02/阅读笔记/index.html">
<meta property="og:site_name" content="湖心亭看雪">
<meta property="og:description" content="以下均为阅读文章所搬运及少部分总结的。 =-= 大自然的搬运工。。 从Chrome源码看DNS解析过程 2018-1-2当一台设备连接到路由器后，会发送DHCP Request的广播，然后会为电脑分配IP地址及DNS服务器地址nameserver。 Chrome会按照nameservers的顺序发起查询，并将结果缓存下来，有效时间是根据域名设置的TTL决定，在有效期内可以根据结果查询。缓存-&amp;gt">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/90068090.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/76791019.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/20543836.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/5961679.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/61189215.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-8/58541315.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-9/66355814.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-11/95662756.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-11/46119128.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-11/69903717.jpg">
<meta property="og:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-11/6878478.jpg">
<meta property="og:updated_time" content="2018-01-12T15:58:58.767Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阅读笔记">
<meta name="twitter:description" content="以下均为阅读文章所搬运及少部分总结的。 =-= 大自然的搬运工。。 从Chrome源码看DNS解析过程 2018-1-2当一台设备连接到路由器后，会发送DHCP Request的广播，然后会为电脑分配IP地址及DNS服务器地址nameserver。 Chrome会按照nameservers的顺序发起查询，并将结果缓存下来，有效时间是根据域名设置的TTL决定，在有效期内可以根据结果查询。缓存-&amp;gt">
<meta name="twitter:image" content="http://oqp1ywek9.bkt.clouddn.com/18-1-6/90068090.jpg">
  
    <link rel="alternate" href="/atom.xml" title="湖心亭看雪" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">湖心亭看雪</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-阅读笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/02/阅读笔记/" class="article-date">
  <time datetime="2018-01-02T03:04:50.000Z" itemprop="datePublished">2018-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习成长/">学习成长</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      阅读笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下均为阅读文章所搬运及少部分总结的。</p>
<p>=-= 大自然的搬运工。。</p>
<h2 id="从Chrome源码看DNS解析过程-2018-1-2"><a href="#从Chrome源码看DNS解析过程-2018-1-2" class="headerlink" title="从Chrome源码看DNS解析过程 2018-1-2"></a>从Chrome源码看DNS解析过程 2018-1-2</h2><p>当一台设备连接到路由器后，会发送DHCP Request的广播，然后会为电脑分配IP地址及DNS服务器地址nameserver。</p>
<p>Chrome会按照nameservers的顺序发起查询，并将结果缓存下来，有效时间是根据域名设置的TTL决定，在有效期内可以根据结果查询。<br>缓存-&gt;本地host文件(Chrome以Map形式保存host)-&gt;nameserver查询。</p>
<p>A - 把域名解析到一个IPV4地址上<br>AAAA - 把域名解析到一个IPV6地址上<br>CNAME - 解析到另外一个域名(当很多其它域名指向一个CNAME时，当需要改变IP地址时，只要改变这个CNAME的地址，那么其它的也跟着生效了，但是得做二次解析。)</p>
<h2 id="缓存穿透、缓存并发、缓存失效之思路变迁"><a href="#缓存穿透、缓存并发、缓存失效之思路变迁" class="headerlink" title="缓存穿透、缓存并发、缓存失效之思路变迁"></a>缓存穿透、缓存并发、缓存失效之思路变迁</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB,如果大量请求(缓存不存在),导致 <strong>缓存穿透</strong> ,DB可能挂掉。</p>
<p>解决方法：<br>可以将这个不存在的key预先设定一个值。避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。</p>
<h3 id="缓存并发"><a href="#缓存并发" class="headerlink" title="缓存并发"></a>缓存并发</h3><p>一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。</p>
<p>解决方法：<br>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁。其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</p>
<h3 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h3><p>在同一时间，出现多个缓存失效。</p>
<p>解决方法：<br>缓存失效时间分散开来。</p>
<h2 id="面向GC的JAVA编程-2018-1-3"><a href="#面向GC的JAVA编程-2018-1-3" class="headerlink" title="面向GC的JAVA编程 2018-1-3"></a>面向GC的JAVA编程 2018-1-3</h2><p>(1)不要使用<code>Thread.yield()</code>和<code>System.gc()</code>(除非你真的需要回收Native Memory)</p>
<p>(2)如果可以的话，请指定容器初始化大小。</p>
<p>(3)如果可以在方法内声明的局部变量，就不要声明为实例变量。</p>
<p>(4)除非你的对象是单例的或不变的，否则尽可能少地声明static变量。不然，会一直留在内存里。</p>
<p>(5)引用</p>
<ul>
<li>Strong Reference，最常见的引用</li>
<li>Weak Reference，当没有指向它的强引用时会被GC回收</li>
<li>Soft Reference，只当临近OOM时才会被GC回收</li>
<li>Phantom Reference，主要用于识别对象被GC的时机，通常用于做一些清理工作</li>
</ul>
<h2 id="从LONGADDER看更高效的无锁实现"><a href="#从LONGADDER看更高效的无锁实现" class="headerlink" title="从LONGADDER看更高效的无锁实现"></a>从LONGADDER看更高效的无锁实现</h2><p><code>AtomicLong</code>的实现方式是内部有个value 变量，当多线程并发自增，自减时，均通过CAS 指令从机器指令级别操作保证并发的原子性。</p>
<p><code>LongAddr</code>解决办法是：减少并发，将单一value的更新压力分担到多个value中去，降低单个value的 “热度”，分段更新，最后将Value相加。先使用CAS进行更新，如果不成功再执行上面的操作。将Value放在Cells数组里。</p>
<h2 id="四个流行的JAVA连接池-2018-1-4"><a href="#四个流行的JAVA连接池-2018-1-4" class="headerlink" title="四个流行的JAVA连接池 2018-1-4"></a>四个流行的JAVA连接池 2018-1-4</h2><p>(1)C3P0是一个开放源代码的JDBC连接池。它实现了数据源和JNDI绑定，使用它的开源项目有Hibernate，Spring等。c3p0有自动回收空闲连接的功能，提供了最大空闲时间。当超过最大空闲时间，连接会断开。</p>
<p>(2)DBCP(Database Connection Pool)是一个依赖Jakarta commons-pool对象池机制的数据库连接池，Tomcat的数据源使用的就是DBCP。不提供回收空闲连接功能,DBCP提供最大连接数。当连接数超过max，所有连接都会断开。</p>
<p>(3)BoneCP 是一个开源的快速的 JDBC 连接池。</p>
<p>(4)Proxool是一个Java SQL Driver驱动程序，提供了对你选择的其它类型的驱动程序的连接池封装。可以非常简单的移植到现存的代码中。完全可配置。快速，成熟，健壮。</p>
<h2 id="彻底理解事务的4个隔离级别"><a href="#彻底理解事务的4个隔离级别" class="headerlink" title="彻底理解事务的4个隔离级别"></a>彻底理解事务的4个隔离级别</h2><p>事务保证，要么全部执行，要么都不执行，从一个状态转变到另一个状态。<br>事务的隔离级别有4种，由低到高一依次为Read uncommitted、Read committed、Repeatable read、Serializable。<br>这些级别可以解决，脏读、不可重复度、幻读。</p>
<h3 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h3><p>一个事务可以读取另一个未提交事务的数据。可出现脏读。</p>
<h3 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h3><p>一个事务要等另一个事务提交后才能读取数据。可出现不可重复度，解决脏读。</p>
<h3 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h3><p>开始读取数据（事务开启）时，不再允许修改操作。出现幻读，解决不可重复读。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>事务串行化顺序执行，可以避免脏读、不可重复读与幻读。</p>
<h3 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h3><p>原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）</p>
<p>原子性：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。<br>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。<br>隔离性：一个事务的执行不能其它事务干扰。<br>持续性：个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。</p>
<p>改变MySQL隔离级别的方法：<br><code>set session transaction Isolation level read uncommitted</code></p>
<h2 id="Spring核心系列之ApplicationContext-2018-1-6"><a href="#Spring核心系列之ApplicationContext-2018-1-6" class="headerlink" title="Spring核心系列之ApplicationContext 2018-1-6"></a>Spring核心系列之ApplicationContext 2018-1-6</h2><h3 id="Spring中的Resource接口"><a href="#Spring中的Resource接口" class="headerlink" title="Spring中的Resource接口"></a>Spring中的Resource接口</h3><p>Resource接口是Spring提供的，它为应用提供了更强的底层资源访问能力。</p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/90068090.jpg" alt=""></p>
<ul>
<li>ClassPathResource: 以类路径为相对路劲下的资源。</li>
<li>FileSystemResource : 以文件系统路径查找的资源。</li>
<li>ServletContextResource : 以相对于Web应用跟目录的方式访问。</li>
<li>ByteArrayResource: 二进制数组表示的资源。</li>
</ul>
<p>加载Spring下的配置文件<br><code>Resource res =new ServletContectResource(/WEB-INF/classes/spring/application.xml);</code></p>
<p>Spring资源地址表达式<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/76791019.jpg" alt=""></p>
<ul>
<li>?:匹配文件名中的一个字符.</li>
<li>*:匹配文件命中的任意字符.</li>
<li>** :匹配多层路径.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class GaoshiApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">		PathMatchingResourcePatternResolver resolver=new PathMatchingResourcePatternResolver();</span><br><span class="line">		Resource[] res =resolver.getResources(&quot;file:/Users/zdy/Desktop/sql.txt&quot;);</span><br><span class="line">		for (Resource  resource : res)&#123;</span><br><span class="line">			System.out.println(resource.getDescription()+&quot;----&quot;+resource.getFilename());</span><br><span class="line">		&#125;</span><br><span class="line">		SpringApplication.run(GaoshiApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">URL [file:/Users/zdy/Desktop/sql.txt]----sql.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h3><p>ApplicationContext继承自BeanFactory，提供的功能更加强大，一般情况下都是使用ApplicationContext。</p>
<p>ApplicationContext也就是我们说的Spring容器。</p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/20543836.jpg" alt=""></p>
<ul>
<li>ApplicationEventPublisher: 让容器拥有发布应用程序上下文事件的功能.</li>
<li>ResourcePatternResolver:实现了类似于资源加载器的功能，能够识别特定前缀加Ant风格的路径并加载到容器中.</li>
<li>LifeCycle：管理容器中bean的生命周期。</li>
<li>ConfigurableApplicationContext:主要新增了refresh()和close()方法，让ApplicationContext有用了启动，关系和刷新上下文的功能。</li>
<li><strong>ClassPathXmlApplicationContext与FileSystemXmlApplicationContext</strong>:Spring提供的两个常用的ApplicationContext实现类，前者默认从类路径加载配置文件，后者从文件系统加载。<br>然后初始化一个ApplicationContext看看:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac =new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class="line">ApplicationContext ac =new FileSystemXmlApplicationContext(/User/Desktop/application.xml);</span><br></pre></td></tr></table></figure>
<p>ClassPathXmlApplicationContext如果没有前缀默认就是classpath:</p>
<p>FileSystemXmlApplicationContext如果没有前缀默认就是 file:</p>
<p>WebApplicationContext与ServletContext可以相互获得.在非Web应用的环境下，Bean只有singleton和prototype两种作用域，而WebApplicationContext为Bean添加了三个新的作用域:request,session,global session。</p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/5961679.jpg" alt=""></p>
<p>XmlWebApplicationContext和AnnotationConfigWebApplicationContext，大家猜都应该猜到了，一个是XML配置的，一个是<code>@Configuration</code>配置的。</p>
<p>WebApplicationContext和ServletContext相互获取</p>
<p><strong>WebApplicationContext里有ServletContext成员变量，直接get就完了。在ServletContext里有一个写死的attrbute，也是直接get..而且Spring提供了一个WebApplicationContextUtils来封装了这个写死的attribute.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其实就是直接调用了</span><br><span class="line">ServletContext.getAttribute(ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123;</span><br><span class="line">        return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-6/61189215.jpg" alt=""></p>
<h2 id="JAVA的字符串拼接与性能"><a href="#JAVA的字符串拼接与性能" class="headerlink" title="JAVA的字符串拼接与性能"></a>JAVA的字符串拼接与性能</h2><p>观察String的<code>concat()</code>反编译出来的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">46:  new #6; //class java/lang/StringBuilder</span><br><span class="line">49:  dup</span><br><span class="line">50:  invokespecial   #7; //Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">53:  aload_1</span><br><span class="line">54:  invokevirtual   #8; //Method java/lang/StringBuilder.append:</span><br><span class="line">         (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">57:  ldc #9; //String *</span><br><span class="line">59:  invokevirtual   #8; //Method java/lang/StringBuilder.append:</span><br><span class="line">         (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">62:  invokevirtual   #10; //Method java/lang/StringBuilder.toString:()</span><br><span class="line">         Ljava/lang/String;</span><br><span class="line">65:  astore_1</span><br><span class="line">66:  iinc    7, 1</span><br><span class="line">69:  goto    38</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>concat()</code>方法使用的是StringBuilder,性能和StringBuilder一样，但是由于额外的创建StringBuilder对象和执行<code>.append(str).append(str).toString</code>导致性能稍弱于StringBuilder。</p>
<p><strong>在不考虑线程安全和同步的情况下，为了获得最高的性能，我们应尽量使用StringBuilder</strong></p>
<h2 id="JAVA构造时成员初始化的陷阱-2018-1-7"><a href="#JAVA构造时成员初始化的陷阱-2018-1-7" class="headerlink" title="JAVA构造时成员初始化的陷阱 2018-1-7"></a>JAVA构造时成员初始化的陷阱 2018-1-7</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//基类</span><br><span class="line">public class Base</span><br><span class="line">&#123;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        preProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void preProcess() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Derived extends Base</span><br><span class="line">&#123;</span><br><span class="line">    public String whenAmISet = &quot;set when declared&quot;;</span><br><span class="line"></span><br><span class="line">    @Override void preProcess()</span><br><span class="line">    &#123;</span><br><span class="line">        whenAmISet = &quot;set in preProcess()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Derived d = new Derived();</span><br><span class="line">        System.out.println( d.whenAmISet );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此，打印的结果是:<code>set when declared</code></p>
<p>运行流程:</p>
<ol>
<li>进入Derived 构造函数。</li>
<li>Derived 成员变量的内存被分配。</li>
<li>Base 构造函数被隐含调用。</li>
<li>Base 构造函数调用preProcess()。</li>
<li>Derived 的preProcess 设置whenAmISet 值为 “set in preProcess()”。</li>
<li>Derived 的成员变量初始化被调用。</li>
<li>执行Derived 构造函数体。</li>
</ol>
<p><strong>我们的错误就在于我们把Java中的声明和初始化看成了一体。</strong></p>
<p><strong>在C++的世界中，C++并不支持成员变量在声明的时候进行初始化，其需要你在构造函数中显式的初始化其成员变量的值，看起来很土，但其实C++用心良苦。</strong></p>
<p>JAVA：如果调用的是子类的函数的话，这可能产生问题的：因为在构造子类对象的时候，首先调用父类的构造函数，而这时候如果去调用子类的函数，由于子类还没有构造完成，子类的成员尚未初始化，这么做显然是不安全的。</p>
<h2 id="深入理解Java-try-with-resource"><a href="#深入理解Java-try-with-resource" class="headerlink" title="深入理解Java try-with-resource"></a>深入理解Java try-with-resource</h2><p>所有打开的系统资源，比如流、文件或者Socket连接等，都需要被开发者手动关闭，否则随着程序的不断运行，资源泄露将会累积成重大的生产事故。</p>
<p>我们使用jdk1.7里新增的try-with-resource语法糖来打开资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;)));</span><br><span class="line">             BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123;</span><br><span class="line">            int b;</span><br><span class="line">            while ((b = bin.read()) != -1) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>动手实践:<br>为了能够配合try-with-resource，资源必须实现AutoClosable接口。该接口的实现类需要重写close方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Connection implements AutoCloseable &#123;</span><br><span class="line">    public void sendData() &#123;</span><br><span class="line">        System.out.println(&quot;正在发送数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;正在关闭连接&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (Connection conn = new Connection()) &#123;</span><br><span class="line">            conn.sendData();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:  close自动被调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正在发送数据</span><br><span class="line">正在关闭连接</span><br></pre></td></tr></table></figure></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>编译器自动帮我们生成了finally块，并且在里面调用了资源的close方法，所以例子中的close方法会在运行的时候被执行。</p>
<p>编译器生成finally代码之外还在里头生成了<code>addSuppressed()</code>方法,他支持将一个异常附加到另一个异常身上，从而避免异常屏蔽。保证close如果抛出异常，不会被屏蔽掉。</p>
<h2 id="Git远程操作详解-2018-1-8"><a href="#Git远程操作详解-2018-1-8" class="headerlink" title="Git远程操作详解 2018-1-8"></a>Git远程操作详解 2018-1-8</h2><p>Git常用命令：</p>
<ul>
<li>git clone</li>
<li>git remote</li>
<li>git fetch</li>
<li>git pull</li>
<li>git push</li>
</ul>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-8/58541315.jpg" alt=""></p>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;版本库的网址&gt;</span><br><span class="line"></span><br><span class="line">$ git clone https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。<br><code>git remote</code> 列出所有远程主机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<p>克隆的时候，指定远程主机叫做jQuery。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -o jQuery https://github.com/jquery/jquery.git</span><br><span class="line">$ git remote</span><br><span class="line">jQuery</span><br></pre></td></tr></table></figure></p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>一旦远程主机remote有了更新(Git术语叫commit)，需要将这些更新取回本地，这时需要<code>git fetch</code>命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将某个远程主机的更新，全部取回本地。</span><br><span class="line">$ git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。<br>默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">取回特定分支的更新，可以指定分支名。</span><br><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line">取回origin主机的master分支</span><br><span class="line">$ git fetch origin master</span><br></pre></td></tr></table></figure></p>
<p><code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure></p>
<p>本地分支<code>master</code>,远程分支<code>origin/master</code>.</p>
<p><code>git checkout</code>创建一个新的分支。</p>
<p>在<code>orign/master</code>基础上，创建一个新分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure></p>
<p>然后可以使用<code>git merge</code>或<code>git rebase</code>命令，将本地分支合并到远程分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line"># 或者   合并到origin/master上</span><br><span class="line">$ git rebase origin/master</span><br></pre></td></tr></table></figure></p>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code>，取回远程主机某个分支的更新，再与本地的指定分支合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
<p>比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin next:master</span><br></pre></td></tr></table></figure></p>
<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<p>面试爱问的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin next</span><br></pre></td></tr></table></figure></p>
<p>解释：拉去远程origin/next分支，然后在本地分支和它合并。<br>和下面代码功能相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">$ git merge origin/next</span><br></pre></td></tr></table></figure></p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><code>git push</code>用于将本地分支的更新，推送到远程主机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="AWK使用"><a href="#AWK使用" class="headerlink" title="AWK使用"></a>AWK使用</h2><p>AWK:是一个行文本处理工具。它是逐行处理文件中的数据。<br>语法:<code>awk &#39;pattern+{action}&#39;</code><br>解释:<br>(1)大括号<code>{}</code>表示为一个命令分组。<br>(2)pattern是过滤器，pattern成功的才能执行action动作。</p>
<p>实例:显示<code>hello.txt</code>第三行到第六行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | awk &apos;NR==3, NR==6&#123;print;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p>FS：分隔符，默认是空格<br>NR： 当前行数，从1开始<br>NF： 当前记录字段个数<br>$0： 当前记录<br>$1~$n: 当前记录第n个字段<br>例子：显示hello.txt中的第3行至第5行的第一列与最后一列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | awk &apos;NR==3, NR==5&#123;print $1,$NF&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h3><p>pattern参数可以是egrep正则中的一个，正则使用<code>/pattern/</code><br>例子：显示WiFi_Log.txt中，正则匹配pid的行<br><code>cat WiFi_Log.txt | awk &#39;/pid/&#39;</code></p>
<ol>
<li>pattern和action可以只有其一，但不能两者都没有；</li>
<li>默认的action是print</li>
</ol>
<p>例子：显示hello.txt中，长度大于100的行号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | awk &apos;length($0)&gt;80&#123;print NR&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><ul>
<li>gsub(r,s)：在$0中用s代替r</li>
<li>index(s,t)：返回s中t的第一个位置</li>
<li>length(s)：s的长度</li>
<li>match(s,r)：s是否匹配r</li>
<li>split(s,a,fs)：在fs上将s分成序列a</li>
<li>substr(s,p)：返回s从p开始的子串</li>
</ul>
<h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>BEGIN和END本质是一个pattern。<br>BEGIN用于awk程序开始开始前，做一些初始化的工作；<br>END用于awk程序结束前，做一些收尾的工作。</p>
<p>例子：统计字符个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;</span><br><span class="line">BEGIN</span><br><span class="line">&#123;</span><br><span class="line">count=0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">count+=length($0);</span><br><span class="line">&#125;</span><br><span class="line">END</span><br><span class="line">&#123;</span><br><span class="line">print count;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>流程控制语句 (和java、c、c++一样)<br>（1）if(condition){}else{}<br>（2）while{}<br>（3）do{}while(condition);<br>（4）for(init;condition;step){}<br>（5）break/continue：如果有END，会执行END中的收尾工作</p>
<h3 id="awk与shell交互"><a href="#awk与shell交互" class="headerlink" title="awk与shell交互"></a>awk与shell交互</h3><p>(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">STR=&quot;hello&quot;</span><br><span class="line">echo | awk &apos;&#123;</span><br><span class="line">print &quot;&apos;$&#123;STR&#125;&apos;&quot;;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果： 打印 hello</span><br></pre></td></tr></table></figure>
<p>(2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo hello | awk &apos;&#123;</span><br><span class="line">print $0 | &quot;cat&quot;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：打印 hello  如果没有echo 则 执行cat命令</span><br></pre></td></tr></table></figure>
<h2 id="JAVA内存模型-Infoq-2018-1-9"><a href="#JAVA内存模型-Infoq-2018-1-9" class="headerlink" title="JAVA内存模型(Infoq) 2018-1-9"></a>JAVA内存模型(Infoq) 2018-1-9</h2><ol>
<li>顺序一致性(syn)模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li>
<li>JMM不保证对64位的long型和double型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li>
</ol>
<p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</p>
<p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
<p>Concurrent包的实现示意图：<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-9/66355814.jpg" alt=""></p>
<h2 id="JAVA虚拟机内存组成"><a href="#JAVA虚拟机内存组成" class="headerlink" title="JAVA虚拟机内存组成"></a>JAVA虚拟机内存组成</h2><ol>
<li><p><strong>方法区</strong>:用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。<br>可以通过<code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 参数限制方法区的大小。<br><strong>运行时常量池</strong> 方法区的一部分，用于存放编译器生成的各种符号引用。</p>
</li>
<li><p><strong>虚拟机栈</strong>：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。</p>
</li>
</ol>
<p>其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。</p>
<p>当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的。在编译期确定好的。</p>
<ol>
<li><p><strong>本地方法栈</strong>:与虚拟机栈基本类似,区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p>
</li>
<li><p><strong>堆</strong>:该内存区域存放了对象实例及数组(所有new的对象)。JVM配置参数:<code>-Xms</code>(最小值)和<code>-Xmx</code>(最大值)设置堆大小。<br>分为年轻代，和老年代。</p>
</li>
<li><p><strong>程序计数器</strong>:PC指针，记录执行位置。</p>
</li>
<li><p><strong>直接内存</strong>:NIO,调用Native方法直接分配堆外内存.</p>
</li>
</ol>
<p><strong>内存溢出</strong>:java虚拟机内存超出了系统所能接受的，系统不能满足需求，于是产生溢出。</p>
<p><strong>内存泄漏</strong>：是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问,该块已分配出来的内存也无法再使用，随着服务器内存的不断消耗，而无法使用的内存越来越多，系统也不能再次将它分配给需要的程序，产生泄露。</p>
<h2 id="Java对象的序列化与反序列化-2018-1-10"><a href="#Java对象的序列化与反序列化-2018-1-10" class="headerlink" title="Java对象的序列化与反序列化 2018-1-10"></a>Java对象的序列化与反序列化 2018-1-10</h2><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>当试图对一个对象进行序列化的时候，如果遇到不支持 <code>Serializable</code> 接口的对象,将抛出 NotSerializableException。</p>
<p>如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成<code>java.io.Serializable</code>接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oos = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;));</span><br><span class="line">oos.wirteOject(user); //序列化</span><br><span class="line"></span><br><span class="line">ois = new ObjectInputStream(new FileInputStream(new File(&quot;tempFile&quot;)));</span><br><span class="line">ois.readObject();</span><br></pre></td></tr></table></figure>
<h3 id="Externalizable接口"><a href="#Externalizable接口" class="headerlink" title="Externalizable接口"></a>Externalizable接口</h3><p><code>Externalizable</code>和<code>Serializable</code>区别：<code>Externalizable</code>继承<code>Serializable</code>。</p>
<p><code>Externalizable</code>接口中定义了两个抽象方法：writeExternal()与readExternal()。</p>
<p>当使用<code>Externalizable</code>接口来进行序列化与反序列化的时候需要开发人员重写<code>writeExternal()</code>与<code>readExternal()</code>方法。</p>
<p>在使用<code>Externalizable</code>进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现<code>Externalizable</code>接口的类必须要提供一个<code>public</code>的无参的构造器。</p>
<p>重写<code>writeExternal()</code>与<code>readExternal()</code>方法，才能完整的保存下来对象状态，否则不会保存对象状态。</p>
<h3 id="ObjectOutput和ObjectInput-接口"><a href="#ObjectOutput和ObjectInput-接口" class="headerlink" title="ObjectOutput和ObjectInput 接口"></a>ObjectOutput和ObjectInput 接口</h3><p>ObjectInput接口 扩展自 DataInput 接口以包含对象的读操作。</p>
<p>ObjectOutput 扩展 DataOutput 接口以包含对象的写入操作。</p>
<h3 id="Transient-关键字"><a href="#Transient-关键字" class="headerlink" title="Transient 关键字"></a>Transient 关键字</h3><p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<h3 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID;</span><br></pre></td></tr></table></figure>
<p>很眼熟吧~</p>
<p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致。</p>
<h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><blockquote>
<p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
</blockquote>
<p>设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果.<br><strong>模式名称</strong>:以便更好地理解模式并方便开发人员之间的交流.</p>
<p><strong>问题(Problem)</strong>:描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；</p>
<p><strong>解决方案(Solution)</strong>:描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述；</p>
<p><strong>效果(Consequences)</strong>:描述了模式的优缺点以及在使用模式时应权衡的问题。</p>
<p>根据它们的用途，设计模式可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种。</p>
<p><strong>创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责</strong></p>
<p>在学习每一个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。</p>
<h2 id="面向对象设计原则-2018-1-11"><a href="#面向对象设计原则-2018-1-11" class="headerlink" title="面向对象设计原则 2018-1-11"></a>面向对象设计原则 2018-1-11</h2><ol>
<li>单一职责原则:一个类只负责一个功能领域中的相应职责.</li>
<li>开闭原则:软件实体应对扩展开放，而对修改关闭.</li>
<li>里氏代换原则:所有引用基类对象的地方能够透明地使用其子类的对象</li>
<li>依赖倒转原则:抽象不应该依赖于细节，细节应该依赖于抽象</li>
<li>接口隔离原则:使用多个专门的接口，而不使用单一的总接口</li>
<li>合成复用原则:尽量使用对象组合，而不是继承来达到复用的目的.</li>
<li>迪米特法则:一个软件实体应当尽可能少地与其他实体发生相互作用.</li>
</ol>
<h3 id="面向对象设计原则之单一职责原则"><a href="#面向对象设计原则之单一职责原则" class="headerlink" title="面向对象设计原则之单一职责原则"></a>面向对象设计原则之单一职责原则</h3><blockquote>
<p><strong>单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</strong></p>
</blockquote>
<p>单一职责原则告诉我们:在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p>
<p><strong>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则</strong></p>
<p>开发人员针对某CRM（Customer Relationship  Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-11/95662756.jpg" alt=""></p>
<p>如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则.</p>
<p>使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：</p>
<p>(1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；</p>
<p>(2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；</p>
<p>(3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-11/46119128.jpg" alt=""></p>
<h3 id="面向对象设计原则之开闭原则"><a href="#面向对象设计原则之开闭原则" class="headerlink" title="面向对象设计原则之开闭原则"></a>面向对象设计原则之开闭原则</h3><p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
<p><strong>抽象化是开闭原则的关键</strong><br>软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案:<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-11/69903717.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//ChartDisplay代码片段</span><br><span class="line">if (type.equals(&quot;pie&quot;)) &#123;  </span><br><span class="line">    PieChart chart = new PieChart();  </span><br><span class="line">    chart.display();  </span><br><span class="line">&#125;  </span><br><span class="line">else if (type.equals(&quot;bar&quot;)) &#123;  </span><br><span class="line">    BarChart chart = new BarChart();  </span><br><span class="line">    chart.display();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。</p>
<p>由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：</p>
<p>(1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；</p>
<p>(2)  ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。</p>
<p>重构后结构:<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-1-11/6878478.jpg" alt=""></p>
<h2 id="深入分析Java的序列化与反序列化"><a href="#深入分析Java的序列化与反序列化" class="headerlink" title="深入分析Java的序列化与反序列化"></a>深入分析Java的序列化与反序列化</h2><h3 id="ArrayList的序列化"><a href="#ArrayList的序列化" class="headerlink" title="ArrayList的序列化"></a>ArrayList的序列化</h3><p>看下<code>java.util.ArrayList</code>源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private static final long serialVersionUID = 8683452581122892189L;</span><br><span class="line">    transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">    private int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可知：它实现了<code>Serializable</code>接口，可以实现序列化及反序列化。</p>
<p>然而元素都存在<code>elementData</code>数组中，但被<code>transient</code>修饰啦。把元素保存下来通过<code>writeObject</code>方法和<code>readObject</code>方法。</p>
<blockquote>
<p>在序列化过程中，如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。</p>
<p>如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。</p>
<p>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。</p>
</blockquote>
<p>为什么要使用<code>transient</code>?<br>ArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设置为transient。</p>
<p>ObjectOutputStream的writeObject的调用栈：<br><code>writeObject ---&gt; writeObject0 ---&gt;writeOrdinaryObject---&gt;writeSerialData---&gt;invokeWriteObject</code></p>
<p>在使用ObjectOutputStream的writeObject方法和ObjectInputStream的readObject方法时，会通过反射的方式调用。</p>
<p>如果一个类想被序列化，需要实现<code>Serializable</code>接口。否则将抛出<code>NotSerializableException</code>异常，这是因为，在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。</p>
<h2 id="单例与序列化的那些事儿"><a href="#单例与序列化的那些事儿" class="headerlink" title="单例与序列化的那些事儿"></a>单例与序列化的那些事儿</h2><p><strong>单例模式</strong> 可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源.</p>
<p>单例模式并不能保证唯一性：<br>反射可以破坏，使用序列化及反序列化同样可以破坏单例。</p>
<h3 id="序列化对单例的破坏"><a href="#序列化对单例的破坏" class="headerlink" title="序列化对单例的破坏"></a>序列化对单例的破坏</h3><p>双重校验实现单例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton implements Serializable&#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以对<code>Singleton</code>进行序列化和反序列化得到的对象是一个新的对象，这样就破坏了Singleton的单例性。</p>
<p>序列化过程通过ObjectOutputStream和ObjectInputputStream来实现的，那么需要观察<code>readObject</code>方法。<br>调用栈：<br><code>readObject---&gt;readObject0---&gt;readOrdinaryObject---&gt;checkResolve</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private Object readOrdinaryObject(boolean unshared)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        //此处省略部分代码</span><br><span class="line"></span><br><span class="line">        Object obj;</span><br><span class="line">        try &#123;</span><br><span class="line">            obj = desc.isInstantiable() ? desc.newInstance() : null;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw (IOException) new InvalidClassException(</span><br><span class="line">                desc.forClass().getName(),</span><br><span class="line">                &quot;unable to create instance&quot;).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //此处省略部分代码</span><br><span class="line"></span><br><span class="line">        if (obj != null &amp;&amp;</span><br><span class="line">            handles.lookupException(passHandle) == null &amp;&amp;</span><br><span class="line">            desc.hasReadResolveMethod())</span><br><span class="line">        &#123;</span><br><span class="line">            Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">            if (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">                rep = cloneArray(rep);</span><br><span class="line">            &#125;</span><br><span class="line">            if (rep != obj) &#123;</span><br><span class="line">                handles.setObject(passHandle, obj = rep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看这一段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object obj;</span><br><span class="line">try &#123;</span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : null;</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">    throw (IOException) new InvalidClassException(desc.forClass().getName(),&quot;unable to create instance&quot;).initCause(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里创建的这个obj对象，就是本方法要返回的对象，也可以暂时理解为是ObjectInputStream的readObject返回的对象。</p>
<blockquote>
<p><code>isInstantiable</code>：如果一个serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。针对serializable和externalizable我会在其他文章中介绍。</p>
<p><code>desc.newInstance</code>：该方法通过反射的方式调用无参构造方法新建一个对象。</p>
</blockquote>
<p>序列化会通过反射调用无参数的构造方法创建一个新的对象。</p>
<h3 id="防止序列化破坏单例模式"><a href="#防止序列化破坏单例模式" class="headerlink" title="防止序列化破坏单例模式"></a>防止序列化破坏单例模式</h3><p>只要在Singleton类中定义readResolve就可以解决该问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> private Object readResolve() &#123;</span><br><span class="line">	 return singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (obj != null &amp;&amp;</span><br><span class="line">            handles.lookupException(passHandle) == null &amp;&amp;</span><br><span class="line">            desc.hasReadResolveMethod())</span><br><span class="line">        &#123;</span><br><span class="line">            Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">            if (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">                rep = cloneArray(rep);</span><br><span class="line">            &#125;</span><br><span class="line">            if (rep != obj) &#123;</span><br><span class="line">                handles.setObject(passHandle, obj = rep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>hasReadResolveMethod</code>:如果实现了serializable 或者 externalizable接口的类中包含readResolve则返回true</p>
<p><code>invokeReadResolve</code>:通过反射的方式调用要被反序列化的类的readResolve方法。</p>
<p>主要在Singleton中定义readResolve方法，并在该方法中指定要返回的对象的生成策略，就可以方式单例被破坏。</p>
<h2 id="JAVA命令学习-2018-1-12"><a href="#JAVA命令学习-2018-1-12" class="headerlink" title="JAVA命令学习 2018-1-12"></a>JAVA命令学习 2018-1-12</h2><h3 id="常见命令及Java-Dump介绍"><a href="#常见命令及Java-Dump介绍" class="headerlink" title="常见命令及Java Dump介绍"></a>常见命令及Java Dump介绍</h3><ul>
<li>jps:查看本机的Java中进程信息。</li>
<li>jstack:打印线程的栈信息,制作线程Dump。</li>
<li>jmap:打印内存映射,制作堆Dump。</li>
<li>jstat:性能监控工具。</li>
<li>jhat:内存分析工具。</li>
<li>jconsole:简易的可视化控制台。</li>
<li>jvisualvm:功能强大的控制台。</li>
</ul>
<p><strong>什么是Java Dump？</strong><br>Java虚拟机的运行时快照。将Java虚拟机<strong>运行时的状态和信息保存到文件</strong>。</p>
<p><strong>线程Dump</strong>,包含所有线程的运行状态。纯文本格式。</p>
<p><strong>堆Dump</strong>,包含线程Dump,包含所有堆对象的状态。二进制格式。</p>
<p><strong>使用Java虚拟机制作Dump</strong><br><code>-XX:+HeapDumpOnOutOfMemoryError</code><br>指示虚拟机在发生内存不足错误时,自动生成堆Dump。</p>
<p><strong>使用图形化工具制作Dump</strong><br>使用JDK(1.6)自带的工具:Java VisualVM。</p>
<p><strong>使用命令行制作Dump</strong><br><code>jstack</code>:打印线程的栈信息,制作线程Dump。</p>
<p><code>jmap</code>:打印内存映射,制作堆Dump。</p>
<p>步骤：</p>
<ol>
<li>检查虚拟机版本（java -version）</li>
<li>找出目标Java应用的进程ID（jps）</li>
<li>使用jstack命令制作线程Dump</li>
<li>使用jmap命令制作堆Dump</li>
</ol>
<h3 id="Jps"><a href="#Jps" class="headerlink" title="Jps"></a>Jps</h3><blockquote>
<p>jps位于jdk的bin目录下，其作用是显示当前系统的java进程情况，及其id号。 jps相当于Solaris进程工具ps。不象”pgrep java”或”ps -ef grep java”，jps并不使用应用程序名来查找JVM实例。因此，它查找所有的Java应用程序，包括即使没有使用java执行体的那种（例如，定制的启动 器）。另外，jps仅查找当前用户的Java进程，而不是当前系统中的所有进程。</p>
</blockquote>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p><code>JAVA_HOME/bin/</code>目录下面</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>是JDK 1.5提供的一个显示当前所有java进程pid的命令</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>java程序启动后，会在<code>java.io.tmpdir</code>指定的目录下，就是临时文件夹里生成一个<code>hsperfdata_xxx</code>的文件夹，xxx是用户名。里头的文件名为java进程的pid，因此只是输出了文件名而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ pwd</span><br><span class="line">/tmp/hsperfdata_hollis</span><br><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ ll</span><br><span class="line">total 48</span><br><span class="line">drwxr-xr-x 2 hollis hollis  4096  4月 16 10:54 ./</span><br><span class="line">drwxrwxrwt 7 root   root   12288  4月 16 10:56 ../</span><br><span class="line">-rw------- 1 hollis hollis 32768  4月 16 10:57 2679</span><br><span class="line">hollis@hos:/tmp/hsperfdata_hollis$</span><br></pre></td></tr></table></figure></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用<code>jps -help</code>命令来查看如何使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ jps -help</span><br><span class="line">usage: jps [-help]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure></p>
<p>(1)<code>jps -q</code>：只显示pid，不会显示class名称，jar文件名和传递给main方法的参数。<br>(2)<code>jps -m</code>：输出传递给main方法的参数，嵌入式jvm上可能显示为null。<br>(3)<code>jps -l</code>：输出main class的完整package名或应用程序jar完整路径名。<br>(4)<code>jps -v</code>：输出JVM参数。</p>
<h4 id="jps失效情况"><a href="#jps失效情况" class="headerlink" title="jps失效情况"></a>jps失效情况</h4><p><strong>现象</strong>：用<code>ps -ef|grep java</code>能看到启动的java进程，但是用jps查看却不存在该进程的id。</p>
<p><strong>分析</strong>：jps、jconsole、jvisualvm等工具的数据来源都是<code>/tmp/hsperfdata_{userName}/{pid}</code>.<br>所以当文件不存在，或者无法读取时会出现jps无法查到，或者jconsole无法监控。</p>
<p><strong>原因</strong>：<br>（1）用户权限问题导致无法写<code>/tmp</code>或者磁盘已满<br>（2）临时文件丢失，或被清理删除。常用的可能定时删除临时目录的工具为crontab、redhat的tmpwatch、ubuntu的tmpreaper等等。<br>（3）java进程信息文件存储地址被设置，不在/tmp目录下。可通过<code>-Djava.io.tmpdir</code>参数设置，指定文件写入位置。</p>
<h3 id="Jstack"><a href="#Jstack" class="headerlink" title="Jstack"></a>Jstack</h3><blockquote>
<p>jstack是java虚拟机自带的一种堆栈跟踪工具。</p>
</blockquote>
<h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>用于生成java虚拟机当前时刻的线程快照（每一条线程正在执行的方法堆栈的集合）。<strong>生成快照的目的：</strong> 定位线程出现长时间停顿的原因，例如，线程间死锁、死循环、请求外部资源导致的长时间等待等等。</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>NEW：未启动，不会出现在Dump文件中。<br>RUNNABLE：在虚拟机内执行的、正在运行的状态。<br>BLOCKED：受阻塞并等待监视器锁。<br>WATING：无期限等待另一个线程执行特定操作。<br>TIMED_WATING：有时限的等待另一个线程的特定操作。<br>TERMINATED：已退出。</p>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/02/阅读笔记/" data-id="cjc6cag1l000fb0va7gzg67c5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/01/06/Python入门学习(三)-变量与运算符/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Python入门学习(三)-变量与运算符
        
      </div>
    </a>
  
  
    <a href="/2018/01/01/2018年实施计划/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2018年实施计划</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java多线程/">Java多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python基础/">Python基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习成长/">学习成长</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/08/在京东实习的笔记/">京东实习记录</a>
          </li>
        
          <li>
            <a href="/2018/01/06/Python入门学习(三)-变量与运算符/">Python入门学习(三)-变量与运算符</a>
          </li>
        
          <li>
            <a href="/2018/01/02/阅读笔记/">阅读笔记</a>
          </li>
        
          <li>
            <a href="/2018/01/01/2018年实施计划/">2018年实施计划</a>
          </li>
        
          <li>
            <a href="/2017/12/29/JAVA反射/">JAVA反射</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 殷鑫<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>