<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>努力是为了将对世界的所有渴望都掌握在手上</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习之路">
<meta property="og:type" content="website">
<meta property="og:title" content="努力是为了将对世界的所有渴望都掌握在手上">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="努力是为了将对世界的所有渴望都掌握在手上">
<meta property="og:description" content="学习之路">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="努力是为了将对世界的所有渴望都掌握在手上">
<meta name="twitter:description" content="学习之路">
  
    <link rel="alternate" href="/atom.xml" title="努力是为了将对世界的所有渴望都掌握在手上" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">努力是为了将对世界的所有渴望都掌握在手上</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MySQL技术内幕/第四章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/19/MySQL技术内幕/第四章/" class="article-date">
  <time datetime="2018-07-19T12:34:33.000Z" itemprop="datePublished">2018-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/19/MySQL技术内幕/第四章/">第三章 表 读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>表示关于特定实体的数据集合，这是关系型数据库模型的核心。</p>
<h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表成为索引组织表(index organized table)。每张表都有个主键(Primary Key),如果在创建表时没有显示地定义主键，则InnoDB存储引擎会按一下方式选择或创建主键：</p>
<ol>
<li>首先判断表中是否有非空的唯一索引(Unique NOT NULL)，如果有，该列即为主键。</li>
<li>如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针。<br>当表有多个非空索引时，InnoDB存储引擎会选择建表时第一个定义的非空唯一索引为主键。</li>
</ol>
<p><code>_rowid</code>可以显示表的主键，它只能用于查看单个列为主键的情况。</p>
<hr>
<h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>从InnoDB存储引擎的逻辑结构看，所有数据都被逻辑地存放在一个空间中，称它为表空间(tablespace)。表空间又由段(segment)、区(extent)、页(page)组成。页在一些文档中有时也称为块(block),InnoDB存储引擎的逻辑存储结构如图所示。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-8-3/32144704.jpg" alt="InnoDB逻辑存储结构"></p>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>表空间是InnoDB存储引擎逻辑结构的最高层，<strong>所有的数据都存放在表空间中</strong>,在默认情况下，InnoDB存储引擎有一个共享表空间ibdata1,即所有数据都存放在这个表空间内。如果用户启用参数<code>innodb_file_per_table</code>,则每张表内的数据都会单独放到一个表空间内。每个表空间存放的只是数据、索引和插入缓冲Bitmap页，其他类的数据，如回滚(undo)信息，插入缓冲索引页，系统事务信息，二次写缓冲(Double write buffer)等还放在原来共享表空间内。共享表空间还是会不断增大的。<br>用户显示的提交事务，会产生大量的undo操作语句，使得共享表空间增大。即使使用rollback，也不会回收增长的这些空间，如果这些undo信息不需要，那么这些空间会标记为可用空间。</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间由各个段组成，常见的段有数据段、索引段、回滚段等。数据是存储在B+树的叶子节点上的。</p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由连续页组成的表空间，在任何情况下每个区的大小都为1MB。InnoDB存储引擎一次从磁盘申请4~5个区。InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。<br><strong>启动innodb_file_per_table，创建的表怎么默认是96KB？</strong><br>区中是64个连续的页，但在每个段开始时，会先用32个页大小的碎片页(fragment page)来存放数据，使用完这些页之后才是64个连续页的申请。<br>这样做的目的是，对于一些小表或者undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB磁盘管理的最小单位。在InnoDB存储引擎中，默认每个页的大小为16KB。可以通过参数<code>innodb_page_size</code>将页的大小设置为4K、8K、16K。若设置完成后，不可对其再次修改。可通过mysqldump导入导出产生新的库。<br>常见页类型：1.数据页 2.undo页 3.系统页 4.事务数据页 5.插入缓冲位图页 6.插入缓冲空闲列表页 7.未压缩的二进制大对象页 8.压缩的二进制大对象页。</p>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB存储引擎是面向列的，也就是数据按行存储。当然还有面向行的数据库，MySQL infobright存储引擎按列来存放数据，对于数据仓库下的分析类SQL语句的执行及数据压缩非常有帮助。</p>
<h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><p>InnoDB1.0.x之前存储引擎提供了Compact和Redundant两种格式来存放行记录数据。通过<code>SHOW TABLE STATUS LIKE &#39;table_name&#39;</code>来查看当前表使用的行格式，<code>row_format</code>属性表示当前使用的行记录结构类型。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-8-5/12361845.jpg" alt=""><br>这里行格式为Dynamic格式。</p>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>InnoDB存储引擎可以将一条路中某些数据存储在真正的数据页面之外。BLOB可以不将数据放在溢出页面，VARCHAR列数据也可能存放为行溢出数据。<br>VARCHAR并不是真正能存放65535字节，因为还有别的开销，当然字符类型也是问题GBK和UTF-8存储字符个数是不同的，文档中VARCHAR最大支持65535 <strong>字节</strong>。<br>如果页中只能存放下一条记录，那么InnoDB存储引擎会自动将行数据存放到溢出页中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># a长度为9000，一个页只能存一条数据</span><br><span class="line">CREATE TABLE t (</span><br><span class="line">  a VARCHAR(9000)</span><br><span class="line">  )ENGINE=InnoDB;</span><br></pre></td></tr></table></figure></p>
<h4 id="Compressed和Dynamic行记录格式"><a href="#Compressed和Dynamic行记录格式" class="headerlink" title="Compressed和Dynamic行记录格式"></a>Compressed和Dynamic行记录格式</h4><p>这两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式，在数据页只存放20个字节的指针，实际的数据都存放在Off Page中，而之前的Compact和Redundant两种格式会存放768个前缀字节。</p>
<p>Compressed行记录格式另一个功能是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p>
<h4 id="CHAR的行结构存储"><a href="#CHAR的行结构存储" class="headerlink" title="CHAR的行结构存储"></a>CHAR的行结构存储</h4><p>通常我们认为VARCHAR是存储变长长度的字符类型，CHAR是存储固定长度的字符类型。从MySQL4.1版本开始，CHAR(N)中的N指的是字符长度，而不是之前版本的字节长度。也就是说在不同的字符集下，CHAR类型列内部存储的可能不是定长的数据。因此，对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部 将其视为变长字符类型。(多字符集情况下CHAR和VARCHAR存储没区别的)。</p>
<h3 id="InnoDB数据页结构-未阅读"><a href="#InnoDB数据页结构-未阅读" class="headerlink" title="InnoDB数据页结构(未阅读)"></a>InnoDB数据页结构(未阅读)</h3><h3 id="Named-File-Formats机制-未阅读"><a href="#Named-File-Formats机制-未阅读" class="headerlink" title="Named File Formats机制(未阅读)"></a>Named File Formats机制(未阅读)</h3><p>###约束<br>关系数据库本身能保证存储数据的完整性，不需要应用程序去控制，然而文件系统一般需要在程序端控制。<br>数据完整性：1.实体完整性保证表中有一个主键 2.用户可以通过定义主键和唯一性约束来保证实体的完整性。3.用户可以编写触发器保证数据完整性。</p>
<p>域完整性保证数据每列的值满足特定的条件。在InnoDB存储引擎表中，域完整性体现：1.选择合适的数据类型确保一个数据值满足特定条件。<br>2.外键约束 3.编写触发器 4.DEFAULT约束</p>
<p>InnoDB提供以下几种约束：1.Primary Key 2.Unique Key 3.Foreign Key 4.Default 5.NOT NULL</p>
<h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><p>我们可以在创建表时进行约束定义，也可以使用ALTER TABLE命令创建约束。<br>对于唯一索引约束，我们可以通过<code>CREATE UNIQUE INDEX</code>来简历。主键约束名默认是PRIMARY，对于Unique Key约束而言，默认约束名和列名一样。</p>
<h4 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h4><p>约束是一个逻辑概念，是用来保证数据完整性的，而索引是一个数据结构，即有逻辑上的概念，在数据库中还代表着物理存储的方式。</p>
<h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><p>默认情况下，MySQL数据库不允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值，如向NOT NULL的字段插入一个NULL值，会报错，当然修改配置，可以让MySQL将其改为0再插入。</p>
<h4 id="ENUM和SET约束"><a href="#ENUM和SET约束" class="headerlink" title="ENUM和SET约束"></a>ENUM和SET约束</h4><p>MySQL数据库不支持传统的CHECK约束，但通过ENUM和SET类型可以解决部分这样的约束需求。例如，表上有一个性别类型，规定域的范围只能是male或female，这种情况可以通过ENUM类型进行约束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE a &#123;</span><br><span class="line">  id INT,</span><br><span class="line">  sex ENUM(&apos;male&apos;,&apos;female&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><p>触发器作用是执行INSERT、DELETE和UPDATE命令之前或之后自动调用。<br>创建触发器命令是<code>CREATE TRIGGER</code><br>通过触发器，用户可以实现MySQL本身不支持的物化视图、高级复制、审计等特性。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一个命名的虚表，它由一个SQL查询来定义，可以当做表使用。视图中的数据没有实际的物理存储。</p>
<h4 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h4><p>一些程序不需要关心基表的结构，只需要按照视图定义来取数据或更新数据，视图在一定程度上起到一个安全层的作用。<br>用户可以对某些视图进行更新操作。视图定义中的<code>WITH CHECK OPTION</code>就是针对可更新的视图，更新的值是否需要检查。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER VIEW v_t</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM t WHERE id&lt;10</span><br><span class="line">WITH CHECK OPTION;</span><br></pre></td></tr></table></figure></p>
<h3 id="分区表-暂时不想写-没用过"><a href="#分区表-暂时不想写-没用过" class="headerlink" title="分区表(暂时不想写 没用过)"></a>分区表(暂时不想写 没用过)</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/19/MySQL技术内幕/第四章/" data-id="cjko6d3pg000030va1xo5kkfe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL技术内幕/">MySQL技术内幕</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL技术内幕/第三章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/19/MySQL技术内幕/第三章/" class="article-date">
  <time datetime="2018-07-19T12:34:33.000Z" itemprop="datePublished">2018-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/19/MySQL技术内幕/第三章/">第三章 文件 读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://oqp1ywek9.bkt.clouddn.com/18-7-19/49775658.jpg" alt="session.read_buffer_size"><br><img src="http://oqp1ywek9.bkt.clouddn.com/18-7-19/49775658.jpg" alt="global.read_buffer_size"></p>
<h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>日志文件记录了MySQL数据库的各种类型活动。常见的日志文件有:</p>
<ol>
<li>错误日志(error log)</li>
<li>二进制日志(binlog)</li>
<li>慢查询日志(slow query log)</li>
<li>查询日志(log)</li>
</ol>
<h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><p>错误日志文件对MySQL的启动、运行、关闭过程进行了记录。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-7-19/67344062.jpg" alt="错误日志文件名和路径"><br>数据库不能重启时，我们可以通过查错误日志文件来得到相关内容，让我们更好的去修复它。一些警告可以让我们更好的去优化它。（可能告诉我们需要增大InnoDB存储引擎的redo logo等）</p>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>错误日志可得到数据库优化信息，慢查询日志(slow log)可帮助我们定位可能存在问题的SQL语句，从而对SQL语句进行优化。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-7-19/81445115.jpg" alt=""><br>long_query_time:设置SQL查询时间，超过改时间，记录日志。<br>log_slow_queries:设置是否启动慢查询日志，默认为OFF。(为啥我这查不出来。。)<br>log_queries_not_using_indexes:开关，如果SQL语句没使用索引，会被记录。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-7-19/39440375.jpg" alt=""><br>log_throttle_queries_not_using_indexes：若没使用索引，导致日志会不断增加，该参数表示每分钟可以记录未使用索引SQL语句次数。</p>
<p><code>mysqldumpslow -s al -n 10 david.log</code>用户可得到执行时间最长的10条SQL语句。<br>MySQL5.1开始将慢查询日志记录在一张表(mysql.slow_log)中。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-7-20/3900645.jpg" alt=""><br>慢查询默认是FILE格式，我们可以设置为TABLE格式，然后使用SELECT查询。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-7-20/84933067.jpg" alt=""><br>InnoSQL(杭研开发维护的MySQL分支)加强了SQL语句的捕获方式，在原版MySQL基础上增加逻辑读取和物理读取的统计。<br>物理读取：从磁盘进行IO读取的次数。逻辑读取：包含所有的读取，不管是磁盘还是缓冲池。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/19/MySQL技术内幕/第三章/" data-id="cjjsoz5d00000rsval00yggy0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL技术内幕/">MySQL技术内幕</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL技术内幕/第二章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/26/MySQL技术内幕/第二章/" class="article-date">
  <time datetime="2018-06-26T14:34:33.000Z" itemprop="datePublished">2018-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/26/MySQL技术内幕/第二章/">第二章 Innodb存储引擎 读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>InooDB存储引擎是第一个完整支持ACID事务的MySQL存储引擎，特点是：行锁设计、支持MVCC、支持外键、提供一致性非锁定读，并设计用来最有效地利用以及使用内存和CPU 。<br>一致性非锁定读的情况下即使记录因为UPDATE而被加了X锁，其他事务仍然能够读取记录，不会阻塞。，是通过innodb的行多版本实现的，行多版本并不是实际存储多个版本记录而是通过undo实现。</p>
<h3 id="InnoDB存储引擎的版本"><a href="#InnoDB存储引擎的版本" class="headerlink" title="InnoDB存储引擎的版本"></a>InnoDB存储引擎的版本</h3><p>MySQL5.1中支持两个版本的InnoDB，一个是静态编译的InnoDB版本，另一个是动态加载的InnoDB版本。<br>| 版本 | 功能 |<br>| - | :-: |<br>| 静态编译InnoDB版本 | 支持ACID、行锁设计、MVCC |<br>| InnoDB 1.0.x | 继承上述版本所有功能，增加了compress和dynamic页格式 |<br>| InnoDB 1.1.x | 继承上述版本所有功能，增加了Linux AIO、多回滚段 |<br>| InnoDB 1.2.x| 继承上述版本所有功能，增加了全文索引支持、在线索引添加|</p>
<h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p>InnoDB存储引擎由多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下的工作：</p>
<ol>
<li>维护所有进程/线程需要访问的多个内部数据结构。</li>
<li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。</li>
<li>重做日志(redo log)缓冲。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-6-27/34128853.jpg" alt="InnoDB存储引擎体系架构"><br>后台线程主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。</li>
</ol>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>Innodb存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。</p>
<ol>
<li>Master Thread<br>Master Thread是一个非常核心的后台线程，主要负责将缓存池中的数据异步刷新到磁盘，保证数据一致性，包括脏页的刷新、合并插入缓冲(INSERT BUFFER)、UNDO页的回收等。</li>
<li>IO Thread<br>在Innodb存储引擎中大量使用了AIO(Async IO)来处理写IO请求，大大提高数据库性能。IO Thread的工作主要是负责这些IO请求的回调(Callback)处理。Innodb1.0之前有4中IO Thread，分别是write、read、insert buffer、log IO thread。Linux下无法对IO Thread数量进行调整，Windows下可以修改innodb_file_io_threads。从InnoDB1.0.x开始，read thread和write thread分别增大到了4个，并不使用innodb_file_io_threads，分别使用innodb_read_io_threads和innodb_wirte_io_threads参数进行设置。<br>查看innodb版本：<code>SHOW VARIABLES LIKE &#39;innodb_version&#39;\G</code><br><img src="http://oqp1ywek9.bkt.clouddn.com/18-6-27/31355917.jpg" alt="查看innodb版本"><br>查看read/write线程数:<code>SHOW VARIABLES LIKE &#39;innodb_%io_threads&#39;\G</code><br><img src="http://oqp1ywek9.bkt.clouddn.com/18-6-27/47213816.jpg" alt="查看read/write线程数"><br>观察InnoDB中的IO Thread：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">=====================================</span><br><span class="line">2018-06-27 11:33:04 0x3020 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 28 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 6 srv_active, 0 srv_shutdown, 327120 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 327126</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 21</span><br><span class="line">OS WAIT ARRAY INFO: signal count 14</span><br><span class="line">RW-shared spins 0, rounds 29, OS waits 11</span><br><span class="line">RW-excl spins 0, rounds 44, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 29.00 RW-shared, 44.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 246788</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 244811 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 3376</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 283520093906736, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">I/O thread 0 state: wait Windows aio (insert buffer thread)</span><br><span class="line">I/O thread 1 state: wait Windows aio (log thread)</span><br><span class="line">I/O thread 2 state: wait Windows aio (read thread)</span><br><span class="line">I/O thread 3 state: wait Windows aio (read thread)</span><br><span class="line">I/O thread 4 state: wait Windows aio (read thread)</span><br><span class="line">I/O thread 5 state: wait Windows aio (read thread)</span><br><span class="line">I/O thread 6 state: wait Windows aio (write thread)</span><br><span class="line">I/O thread 7 state: wait Windows aio (write thread)</span><br><span class="line">I/O thread 8 state: wait Windows aio (write thread)</span><br><span class="line">I/O thread 9 state: wait Windows aio (write thread)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到I/O thread0 是insert buffer thread。读线程的ID总是小于写线程。</p>
<ol>
<li><p>Purge Thread<br>事务被提交后，其所使用的undolog可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。</p>
</li>
<li><p>Page Cleaner Thread<br>作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。</p>
</li>
</ol>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>1.缓冲池<br>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。<br>缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲(insert buffer)、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-7-18/4276288.jpg" alt=""></p>
<p>2.LRU List、Free List和Flush List<br>数据库缓冲池采用LRU算法来管理，不过LRU列表加入了midpoin(t(new midpoint old)，最新访问的页加入到midpoint位置(innodb_old_blocks_pct控制)。然而某些操作会将缓存中的页刷新出。如，索引或数据的扫描操作。导致，下一次读取页时，需要再次访问磁盘。innodb_old_blocks_time用于页读取到midpoint位置后需要等待多久才会被加入到LRU热端(new)。当进行数据或索引扫描时，需要设置这些数值。<br>数据库启动时，LRU列表是空的，此时页都存放在Free List中，当需要时从Free列表中移除加入进LRU列表。<br>page made young:old部分加入到new部分。<br>压缩页功能：原本16KB的页压缩为1KB、2KB、4KB和8KB。LRU中的页包含了unzip_LRU列表的页。<br>unzip_LRU通过伙伴算法进行内存分配，对压缩大小不同的页进行分别管理。<br>从缓冲池中申请页为4KB的大小：</p>
<ol>
<li>检查4KB的unzip_LRU列表，检查是否有可用的空闲页。</li>
<li>若有，则直接使用。</li>
<li>否则，检查8KB的unzip_LRU列表。</li>
<li>若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表。</li>
<li>若不能得到空闲页,从LRU列表申请16KB页，分为1个8KB，2个4KB，放到unzip_LRU列表中。</li>
</ol>
<p>LRU列表用来管理缓冲池中页的可用性，Flush列表用于管理将页刷新回磁盘。</p>
<p>3.重做日志缓冲(redo log buffer)<br>InnoDB存储引擎首先将重做日志信息放入到这个缓冲区中，然后按照一定频率将其刷新到重做日志文件。一般情况下每一秒都会刷新到日志文件。<br>重做日志在下列三种情况下会将重做日志缓冲中的内容刷新到外部磁盘中：</p>
<ol>
<li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件中；</li>
<li>每个事务提交时会将重做日志缓冲刷新到重做日志文件；</li>
<li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件中。</li>
</ol>
<p>4.额外的内存池<br>在对一些数据结构本身的内存进行分配时(LRU、锁、等待等信息)，需要从这个额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p>
<h4 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h4><p>该技术解决的问题有：1.缩短数据库的恢复时间(日志大小不会非常大) 2.缓冲池不够时，将脏页刷新到磁盘 3.重做日志不可用时，刷新脏页。</p>
<p>redo log：记录事务将要变更后的状态。<br>undo log：记录事务变更前的状态。</p>
<h4 id="Master-Thread工作方式"><a href="#Master-Thread工作方式" class="headerlink" title="Master Thread工作方式"></a>Master Thread工作方式</h4><p>每一秒，都要将日志缓冲刷新到磁盘(即使事务还没提交),当IO次数少时进行合并插入缓冲(insert buffer写入磁盘),根据脏页比例(buf_get_pages_oct)进行脏页刷新。</p>
<h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><p>1.insert buffer-提高性能<br>Inoodb只有一个聚集索引，剩下的都是非聚集索引，插入不再是顺序的，需要离散地访问非聚集索引页，由于随机读取的存在导致插入操作性能下降。(跟图书馆还书一样，管理员要看是否是唯一的，然后再放入，产生多余的IO操作)<br>Insert Buffer使用需要满足下面两个条件：1.索引是辅助索引 2.索引不是唯一的。<br>Insert Buffer的数据结构是一颗B+树。<br>2.两次写-提高数据页的可靠性<br>在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘，完成后，再将doublewrite buffer中的页写入各个表空间文件中，写入是离散的。<br>保证了数据库宕机时，可能Innodb正在写入某个页到表中，该页只写入了一部分，可以得到恢复。(部分写失效)<br>3.自适应哈希索引<br>AHI是通过缓冲池的B+树页构造而来，Innodb会自动根据访问的频率和模式来自动的为某些热点页建立哈希索引。<br>要求：</p>
<ol>
<li>对这个页的连续访问模式必须是一样的.</li>
</ol>
<ul>
<li>WHERE a=XXX</li>
<li>WHRER a=XXX and b=XXX<br>上面查询交替进行查询，不会对该页构造AHI。</li>
</ul>
<ol>
<li>以该模式访问了100次。</li>
<li>页通过该模式访问了N次，其中N = 页中记录*1/16<br>哈希索引只能用来搜索等值查询，不适合范围查询。<br>4.异步IO<br>(1)全部IO请求都发出去，然后再等待IO操作完成的响应。<br>(2)IO Merge.可将多个IO进行合并。<br>例如:访问(8,6),(8,7),(8,8),每页16KB，可以从(8,6)开始读，读取48KB的页就好了。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/26/MySQL技术内幕/第二章/" data-id="cjjko8yls0001a8va3diefdri" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL技术内幕/">MySQL技术内幕</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL技术内幕/第五章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/26/MySQL技术内幕/第五章/" class="article-date">
  <time datetime="2018-06-26T14:34:33.000Z" itemprop="datePublished">2018-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/26/MySQL技术内幕/第五章/">第五章 索引与算法 读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>索引太多，应用程序性能可能会收到影响。索引太少，对查询性能会产生影响。</p>
<h3 id="InnoDB存储引擎索引概述"><a href="#InnoDB存储引擎索引概述" class="headerlink" title="InnoDB存储引擎索引概述"></a>InnoDB存储引擎索引概述</h3><p>InnoDB存储引擎支持以下几种常见索引：1.B+树索引 2.全文索引 3.哈希索引<br>哈希索引是自适应的，会根据表的使用情况自动为表生成哈希索引，不能人为干预。<br>B+树索引的构造类似于二叉树，根据键值快速找到数据。(B表示平衡balance)<br><strong>注意</strong>：B+树索引并不能找到一个给定键值的具体行，它能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<p>二叉查找树：左子树的键值总小于根的键值，右子树的键值总是大于根的键值。<br>平衡二叉树：符合二叉查找树的定义，其次满足任何节点的两个子树的高度最大差为1.</p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树在数据库中有一个特点是高扇出性，因此B+树高度一般在2~4层，查找某一键值的行记录最多需要2~4次。<br>B+树索引分聚集索引和辅助索引，这两索引都使用B+树，高度平衡，叶子存放所有数据。聚集索引叶子节点存放整行数据信息，而辅助索引叶子节点存放的是主键值。</p>
<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。而聚集索引(clustered index)是按照每张表的主键构造一颗B+树，同时叶子节点存放的是整张表的行记录数据，它的叶子节点也称为数据页。同时每个数据页间通过双向链表来进行链接，便于范围查找。</p>
<p>聚集索引的存储并不是物理上连续的，而是逻辑上连续的。若按照特定顺序存放，维护成本高。</p>
<p>执行EXPLAIN得到MySQL数据库执行计划，并在rows列中给出一个查询结果的预估返回行数。row只是表示预估值。</p>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>辅助索引也称非聚集索引，辅助索引的叶子节点存放你相应行数据的聚集索引键。辅助索引不影响聚集索引中的组织，因此可以有多个。如果通过辅助索引搜索，那么获取到主键值后，还需再一次在聚集索引中查找一次。</p>
<h4 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h4><p><img src="http://oqp1ywek9.bkt.clouddn.com/18-8-9/29648564.jpg" alt=""><br>Table：索引所在的表名<br>Non_unique：非唯一的索引。<br>Key_name：索引名字，用户通过这个名字执行DROP INDEX;<br>Seq_in_index：索引中该列的位置。<br>Column_name：索引名称。<br>Collation：列以什么方式存储在索引中。A-》B+树，NULL-》Hash索引<br>Cardinality：表示索引中唯一值的数目的估计值。接近1最好，非常小可以考虑删除索引。<br>Sub_part：是否是列的部分索引<br>Packed：关键字如何被压缩。没有被压缩，则为NULL。<br>NULL：是否索引的列还有NULL值。<br>Index_type：索引类型。<br>Comment：注释</p>
<p>Cardinality值非常关键，优化器会根据此值判断是否使用这个索引，Cardinality不是实时更新的，即并非每次索引的更新都会更新该值。这个值不是准确的，如果需要更新索引Cardinality的信息，可以使用命令<code>ANALYZE TABLE</code>命令。<br>有时，Cardinality会出现为NULL的情况，最好的解决办法是在非高峰期，对核心表做<code>ANALYZE TABLE</code>操作。</p>
<p>在MySQL5.5版本之前，MySQL对于索引添加或删除的操作流程是这样的：</p>
<ol>
<li>创建一张新的临时表，表结构通过命令<code>ALTER TABLE</code>来重新定义。</li>
<li>把原表中的数据导入到临时表。</li>
<li>删除原来的表。</li>
<li>把临时表重名为原来的表名。</li>
</ol>
<p>对于一张大表来说进行索引的添加和删除操作，需要很长时间。若有大量事务需要访问正在被修改的表，这意味着数据库服务不可用。</p>
<p>InnoDB存储引擎从InnoDB1.0.x版本开始支持一种称为Fast Index Creation(快速索引创建方式,FIC)。(只适用于辅助索引)<br>对于辅助索引的创建，InooDB会对创建索引的表加上一个S锁。删除索引，InnoDB只需更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL数据库内部视图上对该表的索引定义即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/26/MySQL技术内幕/第五章/" data-id="cjko6d3pp000230va0mypjjb0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL技术内幕/">MySQL技术内幕</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL技术内幕/第一章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/25/MySQL技术内幕/第一章/" class="article-date">
  <time datetime="2018-06-25T14:34:33.000Z" itemprop="datePublished">2018-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/25/MySQL技术内幕/第一章/">第一章 MySQL体系结构和存储引擎 读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先，要搞清楚 <strong>数据库</strong> 和 <strong>实例</strong> 这两个词。</p>
<ol>
<li>数据库：物理操作系统文件或其他形式文件类型的集合。数据库只是文件的集合，由文件组成。</li>
<li>实例：MySQL数据库由后台线程以及一个共享内存区域组成。实例是用于操作数据库文件的进程（程序）。一般情况下数据库与实例是一对一的关系。在集群情况下可能存在一个数据库被多个数据库实例使用。</li>
</ol>
<p>MySQL是单进程多线程架构的数据库。MySQL数据库实例在系统表现就是一个进程。</p>
<p>当启动实例时，MySQL数据库会读取配置文件，根据配置文件的参数来启动数据库实例。MySQL数据库中可以没有配置文件，如果没有，MySQL会按照编译时的默认参数设置启动实例。<br>以下命令会查看当MySQL数据库实例启动时，会在哪些位置查找配置文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --help | grep my.cnf</span><br></pre></td></tr></table></figure></p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-6-26/31806869.jpg" alt=""><br>MySQL会按读取到的最后一个配置文件中的参数为准。</p>
<p>###MySQL体系结构<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-6-26/14853787.jpg" alt=""><br>MySQL由以下几个部分组成：连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲(Cache)组件、插件式存储引擎、物理文件。<br>存储引擎是基于表的，而不是数据库的。</p>
<h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><p>InnoDB存储引擎支持事务，设计目标主要面向在线事务处理(OLTP)的应用。特点是行锁设计、支持外键、并支持类似Oracle的非锁定读，即默认读取操作不会产生锁。<br>InnoDB存储引擎将数据放在一个逻辑的表空间中。从MySQL4.1版本开始，它可以将每个InnoDB存储引擎表存放到一个独立的ibd文件中。此外，InnoDB存储引擎支持用裸设备(row disk)用来建立其表空间。<br>InnoDB通过多版本并发控制(MVCC)来获得高并发性，并实现了4种隔离级别，默认为REPEATABLE可重复度级别。使用next-key locking的策略避免幻读(phantom)现象的产生。此外，还提供插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。<br>采用聚集(clustered)的方式，因此每张表的存储都是按主键的顺序进行存放。如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，作为主键。</p>
<h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4><p>MyISAM存储引擎不支持事务、表锁设计、支持全文索引，主要面向一些OLAP(联机分析技术)数据库应用。适用于查询多，几乎没插入不需要事务的场景。<br>MyISAM存储引擎只缓存(cache)索引文件，而不缓冲数据文件。<br>MyISAM存储引擎表由MYD和MYI组成，MYD主要存放数据文件，MYI用来存放索引文件。可使用myisampack来压缩数据文件。</p>
<h4 id="NDB存储引擎"><a href="#NDB存储引擎" class="headerlink" title="NDB存储引擎"></a>NDB存储引擎</h4><p>它是一个集群存储引擎。特点是数据全部存放在内存中，NDB数据存储节点可以线性地提高数据库性能，是高可用、高性能的集群系统。<br>NDB存储引擎的连接操作(JOIN)是在MySQL数据库层完成的，而不是存储引擎层，导致查询速度很慢。</p>
<h4 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h4><p>Memory存储引擎将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中数据都将消失。<br>它适合用于存储临时数据的临时表，以及数据仓库中的维度表。Memroy存储引擎默认使用哈希索引，而不是B+树索引。<br>Memory只支持表锁，并发性能差， 不支持TEXT和BLOB列类型。并且，存储变长字段(varchar)时是按照定长字段(char)的方式进行的，因此会浪费内存。<br>MySQL数据库使用Memory存储引擎作为Memory存储引擎作为临时表来存放查询的中间结果集(intermediate result)。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BOLB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘中。之前提到MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有所损失。</p>
<h4 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h4><p>Archive存储引擎只支持INSERT和SELECT操作。Archive存储引擎使用zlib算法将数据行(row)进行压缩后存储。其非常适合存储归档数据，如日志信息。设计目标是提供高速的插入和压缩功能。</p>
<h4 id="Federated存储引擎"><a href="#Federated存储引擎" class="headerlink" title="Federated存储引擎"></a>Federated存储引擎</h4><p>Federated存储引擎表不存放数据，只是指向一台远程MySQL数据库服务器上的表。</p>
<p>我们可以通过SHOW ENGINES语句查看当前使用的MySQL数据库所支持的存储引擎。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-6-26/42466535.jpg" alt=""></p>
<h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><p>连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。</p>
<ol>
<li><p>TCP/IP ：建立一个基于网络的连接请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT * FROM user\G</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名管道和共享内存<br>如果使用命名管道，必须在配置文件中启用<code>--enable-named-pipe</code>选项。<br>如果使用共享内存的连接方式，在配置文件中添加<code>--shared-memory</code>实现。</p>
</li>
<li>UNIX域套接字<br>其只能在MySQL客户端和数据库实例在一台服务器上的情况下使用。配置文件中要指定套接字文件的路径，如<code>--socket=/tmp.mysql.sock</code></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/25/MySQL技术内幕/第一章/" data-id="cjjko8yln0000a8vabofgqoq0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL技术内幕/">MySQL技术内幕</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL必知必会/第二十五二十六二十七三十章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/15/MySQL必知必会/第二十五二十六二十七三十章/" class="article-date">
  <time datetime="2018-06-15T07:37:00.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/15/MySQL必知必会/第二十五二十六二十七三十章/">MySQL必知必会学习笔记(11)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对触发器的支持是在MySQL 5中增加的。MySQL语句在需要时被执行，存储过程也是如此。但是，如果你想要某条语句（或某些语句）在事件发生时自动执行，怎么办呢？</p>
<ol>
<li>每当增加一个顾客到某个数据库表时，都检查其电话号码格式是<br>否正确，州的缩写是否为大写；</li>
<li>每当订购一个产品时，都从库存数量中减去订购的数量；</li>
<li>无论何时删除一行，都在某个存档表中保留一个副本</li>
</ol>
<p>所有这些例子的共同之处是它们都需要在某个表发生更改时自动处理。这确切地说就是触发器。触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于 BEGIN 和 END 语句之间的一组语句）：1.DELETE 2.INSERT 3.UPDATE  其他MySQL语句不支持触发器。</p>
<p>创建触发器时，需要给出4个信息：</p>
<ol>
<li>唯一的触发器名；</li>
<li>触发器关联的表；</li>
<li>触发器应该响应的活动(DELETE,INSERT或UPDATE)</li>
<li>触发器何时执行(处理之前或之后)</li>
</ol>
<p>保持每个数据库的触发器名唯一：MySQL5中，触发器名必须在每个表里唯一。</p>
<p>触发器使用CREATE TRIGGER语句创建。(trigger 翻译为 触发；使运行)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &apos;Product added&apos;;</span><br><span class="line">-- 会报错 在mysql的trigger和function中不能出现select * from table形式的查询，因为其会返回一个结果集；</span><br><span class="line">-- [Err] 1415 - Not allowed to return a result set from a trigger</span><br><span class="line">-- 以使用用户变量在function中，然后在外部使用select @用户变量查看你的变量值</span><br></pre></td></tr></table></figure></p>
<p>CREATE TRIGGER 用来创建名为 newproduct 的新触发器。触发器可在一个操作发生之前或之后执行，这里给出了 AFTER INSERT ，所以此触发器将在 INSERT 语句成功执行后执行。这个触发器还指定 FOREACH ROW ，因此代码对每个插入行执行。</p>
<p>DELETE触发器：在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，访问被删除的行。OLD的值全部只读，不能更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 演示使用 OLD 保存将要被删除的行到一个存档表中</span><br><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">  INSERT INTO archive_orders(order_num, order_date, cust_id)</span><br><span class="line">  VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p>
<p>UPDATE触发器：</p>
<ol>
<li>在UPDATE触发器代码时，可以引用一个名为OLD的虚拟表访问以前的值，引用一个名为NEW的虚拟表访问新更新的值。</li>
<li>在BEFORE UPDATE触发器中,NEW中的值可能也被更新。</li>
<li>OLD中的值全都是只读的，不能更新。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 保证州名是大写</span><br><span class="line">CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state);</span><br></pre></td></tr></table></figure>
<p>每次更新一行时，NEW.vend_state中的值都用Upper(NEW.vend_state)替换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>创建触发器可能需要特殊的安全访问权限，但是触发器的执行不需要。</li>
<li>应该用触发器来保证数据的一致性。</li>
<li>MYSQL触发器不支持CALL语句。</li>
</ol>
<p>学习了什么是触发器，如何创建，如何使用它。</p>
<h2 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h2><p>MyISAM不支持事务管理，InnoDB支持事务管理。 事务处理可以用来维护数据库的完整性(原子性)，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p>
<p>事务(transaction):指一组SQL语句。<br>回退(rollback):指撤销执行SQL语句的过程。<br>提交(commit):指将未存储的SQL语句结果写入数据库表。<br>保留点(savepoint):指事务处理中设置的临时占位符，你可以对它发布回退。</p>
<h3 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h3><p>MySQL使用下面的语句来标识事务的开始：<code>START TRANSACTION</code></p>
<h4 id="使用ROLLBACK"><a href="#使用ROLLBACK" class="headerlink" title="使用ROLLBACK"></a>使用ROLLBACK</h4><p>MySQL的ROLLBACK命令用来撤销MySQL语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM odertotals;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM ordertotals;</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM ordertotals;</span><br></pre></td></tr></table></figure></p>
<p>ROLLBACK只能在一个事务处理内使用(在执行一条START TRANSACTION命令后)。</p>
<p><strong>哪些语句可以回退？</strong><br>事务处理用来管理INSERT、UPDATE和DELETE语句，不能回退SELECT语句。也不能回退CREATE或DROP操作。事务处理块中可以使用这两天语句，但如果执行回退，他们不会被撤销。</p>
<h4 id="使用COMMIT"><a href="#使用COMMIT" class="headerlink" title="使用COMMIT"></a>使用COMMIT</h4><p>一般的MySQL语句都是直接针对数据库表执行和编写的，提交操作是自动进行的。<br>但是，在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用COMMIT语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num = 20010;</span><br><span class="line">DELETE FROM orders WHERE order_num = 20010;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></p>
<p>如果第一条DELETE起作用，但第二条失败，则DELETE不会提交(实际上，它是被自动撤销的)<br><strong>隐含事务关闭：</strong> 当COMMIT或ROLLBACK语句执行后，事务会自动关闭(将来的更改会隐含提交)。</p>
<h4 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h4><p>简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。<br>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。如果需要回退，可以回退到某个占位符。<br>占位符称为保留点，为了创建占位符，可以使用SAVEPOINT语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT delete1;</span><br></pre></td></tr></table></figure></p>
<p>每个保留点都取标识它的唯一名字，以便在回退时，MySQL知道要回退到何处，为了回退到保留点，可进行：<code>ROLLBACK TO delete1;</code></p>
<p>保留点在事务完成后释放。</p>
<h4 id="更改默认的提交行为"><a href="#更改默认的提交行为" class="headerlink" title="更改默认的提交行为"></a>更改默认的提交行为</h4><p>默认的MySQL行为是自动提交所有更改，为指示MySQL不自动提交更改，需要使用以下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit=0;</span><br></pre></td></tr></table></figure></p>
<p>autocommit标志决定是否自动提交更改，不管有没有COMMIT语句。设置autocommit为0(假)指示MySQL不自动提交更改(直到autocommit被设置为真为止)。<br><strong>标志为连接专用：</strong> autocommit标志是针对 <strong>每个连接</strong> 2而不是服务器的。</p>
<h2 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h2><h3 id="字符集和校对顺序"><a href="#字符集和校对顺序" class="headerlink" title="字符集和校对顺序"></a>字符集和校对顺序</h3><p>数据库表被用来存储和检索数据。不同的语言和字符集需要以不同的方式存储和检索。因此，MySQL需要适应不同的字符集(不同的字母和字符),适应不同的排序和检索数据的方法。</p>
<p><strong>字符集：</strong> 为字母和符号的集合。<br><strong>编码：</strong> 为某个字符集成员的内部表示。<br><strong>校对：</strong> 为规定字符如何比较的指令。</p>
<h3 id="使用字符集和校对顺序"><a href="#使用字符集和校对顺序" class="headerlink" title="使用字符集和校对顺序"></a>使用字符集和校对顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CHARACTER SET;</span><br></pre></td></tr></table></figure>
<p>显示所有可用的字符集以及每个字符集的描述和默认校对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW COLLATION;</span><br></pre></td></tr></table></figure></p>
<p>显示所有的校对，以及他们适用的字符集。<br>例如， latin1 对不同的欧洲<br>语言有几种校对，而且许多校对出现两次，一次区分大小写（由 <code>_cs</code> 表示），一次不区分大小写（由 <code>_ci</code> 表示）。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-6-17/18493105.jpg" alt=""></p>
<p>为了确定所用的字符集和校对，可使用以下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE `character%`;</span><br><span class="line">SHOW VARIABLES LIKE `collation%`;</span><br></pre></td></tr></table></figure></p>
<h2 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h2><ol>
<li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的，但过一段时间后你可能需要调整内存分配、缓冲区大小等。</li>
<li>MySQL一个多用户多线程的DBMS，它经常同时执行多个任务。如果这些任务中的某个执行缓慢，则所有请求都会执行缓慢。如果性能不良，可使用<code>SHOW PROCESSLIST</code>显示所有活动进程。</li>
<li>使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。</li>
<li>使用正确的数据类型。</li>
<li>绝不要检索比需求还要多的数据。不要使用<code>SELECT *</code></li>
<li>在导入数据时，应该关闭自动提交。</li>
<li>索引数据库表以改善数据检索性能。</li>
<li>SELECT语句有一系列复杂的OR条件，可以使用多条SELECT语句和连接他们的UNION语句，可极大改善性能。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/15/MySQL必知必会/第二十五二十六二十七三十章/" data-id="cjiudwu4t0000jcvakz55b5s4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL必知必会/">MySQL必知必会</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL必知必会/第二十二二十三二十四章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/30/MySQL必知必会/第二十二二十三二十四章/" class="article-date">
  <time datetime="2018-05-30T13:38:00.000Z" itemprop="datePublished">2018-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/30/MySQL必知必会/第二十二二十三二十四章/">MySQL必知必会学习笔记(10)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>MySQL5添加了对视图的支持。视图，是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>开始理解视图，看这个SELECT语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">      AND orderitems.order_num = orders.order_num</span><br><span class="line">      AND prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure></p>
<p>把整个查询包装成一个名为productcustomers的虚拟表,可轻松检索出相同数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM productcustomers</span><br><span class="line">WHERE prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure></p>
<p>productcustomers只是一个视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询。</p>
<h3 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h3><ol>
<li>重用SQL</li>
<li>简化复杂的SQL查询。</li>
<li>使用表的组成部分而不是整个表。</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ol>
<p>可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据。<br>在添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p><strong>性能问题</strong>：因为视图不包含数据，每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套视图，性能会下降的很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</p>
<h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><ol>
<li>与表一样，视图必须唯一命名。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>为了创建视图，必须具有足够的访问权限。</li>
<li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li>
<li>ORDER BY 可以用在视图中，但如果从该视图检索数据 SELECT 中也含有 ORDER BY ，那么该视图中的 ORDER BY 将被覆盖。</li>
<li>视图不能索引，也不能有关联的触发器或默认值。</li>
<li>视图可以和表一起使用。</li>
</ol>
<h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><p>视图使用<code>CERATE VIEW</code>语句来创建。使用 <code>SHOW CREATE VIEW viewname ；</code>来查看创建视图的语句。用DROP删除视图，其语法为<code>DROP VIEW viewname;</code>。更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第 2 条更新语句会创建一个视图；如果要更新的视图存在，则第 2 条更新语句会替换原有视图。</p>
<h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><p>视图最常见的应用是隐藏复杂的SQL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW viewName AS</span><br><span class="line">SELECT * FROM customers;</span><br></pre></td></tr></table></figure></p>
<p><code>SELECT * FROM viewName;</code></p>
<h3 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h3><p>视图另一种常见用途是重新格式化检索出的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &apos; (&apos;, RTrim(vend_country),&apos;)&apos;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-6-10/9057362.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW vendorIocations AS</span><br><span class="line">SELECT Concat(RTrim(vend_name), &apos; (&apos;, RTrim(vend_country),&apos;)&apos;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br><span class="line"># 直接通过视图查询</span><br><span class="line">SELECT * FROM vendorIocations;</span><br></pre></td></tr></table></figure></p>
<h3 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h3><p>视图对于应用普通的WHERE子句也很有用。例如：可以定义customerlist视图，它过滤没有电子邮件地址的客户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW customerlist AS</span><br><span class="line">SELECT cust_id, cust_name, cust_email</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure></p>
<p><strong>WHERE子句与WHERE子句：</strong> 如果从视图检索数据s时使用了一条WHERE子句，则两组子句(一组在视图中，另一组是传递给视图的)将自动组合。</p>
<h3 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h3><p>视图对于简化计算字段的使用特别有用。</p>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>迄今为止的所有视图都是和SELECT语句使用的。视图是可更新的，更新一个视图将更新其基表，如果你对视图增加或删除行，实际上是对其基表增加或删除行。 但，并非所有视图都是可更新的。<br>如果视图定义中有以下操作，则不能进行视图更新：</p>
<ol>
<li>分组</li>
<li>联结</li>
<li>子查询</li>
<li>并</li>
<li>聚集函数</li>
<li>DISTINCT<br>视图主要用于数据检索，而不用更新。</li>
</ol>
<h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><p>我们经常会有一个完整的操作需要多条语句才能完成。例如：</p>
<ol>
<li>为了处理订单，需要核对以保证库存中有相应的物品。</li>
<li>库存中没有的物品需要订购，这需要与供应商进行某种交互。<br>执行这些任务需要用到多条SQL语句，此外，需要执行的具体语句及其次序也不是固定的。</li>
</ol>
<p>我们可以创建 <strong>存储过程</strong> 。它是为了以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<h3 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h3><ol>
<li>通过把处理封装在容易使用的单元中，简化复杂的操作。</li>
<li>由于不要求建立一系列处理步骤，这保证了数据的完整性。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑有变化，只需要更改存储过程的代码。</li>
<li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li>
<li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。</li>
</ol>
<p>使用存储过程有3个好处，简单、安全、高性能。</p>
<p>不过SQL转为存储过程，有一些缺陷：</p>
<ol>
<li>一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。</li>
<li>你可能没有创建存储过程的安全访问权限。</li>
</ol>
<p>MySQL将编写存储过程的安全和访问与执行存储过程的安全和访问区分开来。</p>
<h3 id="使用存储过程-1"><a href="#使用存储过程-1" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><p>MySQL称存储过程的执行为 <strong>调用</strong> ，因此MySQL执行存储过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。</span><br><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">                    @pricehigh,</span><br><span class="line">                    @priceaverage);</span><br></pre></td></tr></table></figure></p>
<p>创建一个存储过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一个返回产品平均价格的存储过程</span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">  SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">  FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p>
<p>用 <code>CREATE PROCEDURE productpricing()</code> 语句定义。如果存储过程接受参数，它们将在 () 中列举出来。此存储过程没有参数，但后跟的 () 仍然需要。 BEGIN 和 END 语句用来限定存储过程体，过程体本身仅是一个简单的 SELECT 语句。</p>
<p>在MySQL处理这段代码时，它创建一个新的存储过程 product-pricing 。没有返回数据，因为这段代码并未调用存储过程，这里只是为以后使用而创建它。</p>
<p>MYSQL命令行客户机的分隔符，默认分隔符为<code>,</code>。这会出现错误,需要用到DELIMITER来临时更改语句分隔符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //   # 分隔符改为 //</span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">  SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">  FROM products;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;   # 恢复原来语句的分隔符</span><br></pre></td></tr></table></figure></p>
<p>使用这个存储过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing();</span><br></pre></td></tr></table></figure></p>
<p><code>CALL productpricing();</code> 执行刚创建的存储过程并显示返回的结果。因为存储过程实际上是一种函数，所以存储过程名后需要有 () 符号（即使不传递参数也需要）。</p>
<p>删除存储过程<code>DROP PROCEDURE productpricing;</code></p>
<p>一般存储过程不显示结果，而是把结果返回给你指定的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># procedure 意思是 程序</span><br><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">  OUT pl DECIMAL(8,2),</span><br><span class="line">  OUT ph DECIMAL(8,2),</span><br><span class="line">  OUT pa DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">  SELECT Min(prod_price)</span><br><span class="line">  INTO pl</span><br><span class="line">  FROM products;</span><br><span class="line">  SELECT Max(prod_price)</span><br><span class="line">  INTO ph</span><br><span class="line">  FROM products;</span><br><span class="line">  SELECT Avg(prod_price)</span><br><span class="line">  INTO pa</span><br><span class="line">  FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p>
<p>每个参数必须具有指定的类型，这里使用十进制值。关键字 OUT 指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持 IN （传递给存储过程）、 OUT （从存储过程传出，如这里所用）和 INOUT （对存储过程传入和传出）类型的参数。存储过程的代码位于 BEGIN 和 END 语句内，如前所见，它们是一系列SELECT 语句，用来检索值，然后保存到相应的变量（通过指定 INTO 关键字）。</p>
<p>执行存储过程语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">                    @pricehigh,</span><br><span class="line">                    @priceaverage);</span><br></pre></td></tr></table></figure></p>
<p><strong>变量名</strong>： 所有MySQL变量名都必须以@开始。<br>检索出产品平均价格：<code>SELECT @priceaverage;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#  ordertotal接受订单号并返回订单号的合计</span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">    IN onnumber INT,</span><br><span class="line">    OUT ototal DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">  SELECT Sum(item_price*quantity)</span><br><span class="line">  FROM orderitems</span><br><span class="line">  WHERE order_num = onumber</span><br><span class="line">  INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>onnumber定义为IN，因为订单号要被传入进存储过程。ototal定义为OUT，因为要从存储过程返回合计。INTO使用ototal存储计算出来的合计。<br>调用该存储过程语句如下：<code>CALL ordertotal(20005, @total);</code>然后<code>SELECT @total;</code></p>
<h3 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h3><p>显示一个存储过程的CREATE语句，使用SHOW CREATE PROCEDURE语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE ordertotal;</span><br></pre></td></tr></table></figure></p>
<p>通过执行该语句，可以获得何时、由谁创建等详细信息的存储过程列表。</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>MySQL5添加了对游标的支持。使用游标的原因：需要在检索出来的行中前进或后退一行或多行。<br>游标，是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。（MySQL游标只用于存储过程）</p>
<h3 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h3><ol>
<li>在能够使用游标前，必须声明(定义)它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。</li>
<li>一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。</li>
<li>对于填有数据的游标，根据需要取出检索各行。</li>
<li>在结束游标的使用时，必须关闭游标。</li>
</ol>
<h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><p>游标用DECLARE语句创建。DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--  定义了名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE ordernumbers CURSOR</span><br><span class="line">  FOR</span><br><span class="line">  SELECT order_num FROM orders;</span><br><span class="line">END ;</span><br></pre></td></tr></table></figure></p>
<p>DECLARE 语句用来定义和命名游标，这里为 ordernumbers 。 存储过程处理完成后，游标就消失（因为 <strong>它局限于存储过程</strong> ）。</p>
<p>游标用OPEN CURSOR语句来打开：<code>OPEN ordernumbers;</code>  (cursor 翻译为 光标)<br>在处理 OPEN 语句时执行查询，存储检索出的数据以供浏览和滚动。<br>游标处理完成后，应当使用如下语句关闭游标：<code>CLOSE ordernumbers;</code><br>CLOSE 释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。<br><strong>隐含关闭：</strong> 如果不明确关闭游标，mysql将会在到达END语句时自动关闭它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">  -- Declare the cursor</span><br><span class="line">  DECLARE ordernumbers CURSOR</span><br><span class="line">  FOR</span><br><span class="line">  SELECT order_num FROM orders;</span><br><span class="line">  -- OPEN the cursor</span><br><span class="line">  OPEN ordernumbers;</span><br><span class="line">  -- CLOSE the cursor</span><br><span class="line">  CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p>
<p>通过使用FETCH语句分别访问它的每一行，FETCH指定检索什么数据(所需的列),检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行(不重复读取同一行).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 从游标中检索单个行（第一行）</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">  -- 定义本地变量</span><br><span class="line">  DECLARE o INT;</span><br><span class="line">  -- Declare the cursor</span><br><span class="line">  DECLARE ordernumbers CURSOR</span><br><span class="line">  FOR</span><br><span class="line">  SELECT order_num FROM orders;</span><br><span class="line">  -- OPEN the cursor</span><br><span class="line">  OPEN ordernumbers;</span><br><span class="line">  -- 获取</span><br><span class="line">  FETCH ordernumbers INTO o;</span><br><span class="line">  SELECT o;</span><br><span class="line">  -- CLOSE the cursor</span><br><span class="line">  CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p>
<p>下面这个例子，循环检索数据，从第一行到最后一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CREATE PRODCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">  -- 声明本地变量</span><br><span class="line">  DECLARE done TINYINT DEFAULT 0;</span><br><span class="line">  DECLARE o INT;</span><br><span class="line">  -- 声明 游标</span><br><span class="line">  DECLARE ordernumbers CURSOR</span><br><span class="line">  FOR</span><br><span class="line">  SELECT order_num FROM orders;</span><br><span class="line">  -- Declare continue handler</span><br><span class="line">  DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1;</span><br><span class="line">  -- Open cursor</span><br><span class="line">  OPEN ordernumbers;</span><br><span class="line">  -- loop through all rows</span><br><span class="line">  REPEAT</span><br><span class="line">    -- Get order number</span><br><span class="line">    FETCH ordernumbers INTO o;</span><br><span class="line">  -- END of loop</span><br><span class="line">  UNTIL done END REPEAT;</span><br><span class="line">  -- Close the cursor</span><br><span class="line">  CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p>
<p>最新版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CREATE PRODCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">  -- 声明本地变量</span><br><span class="line">  DECLARE done TINYINT DEFAULT 0;</span><br><span class="line">  DECLARE o INT;</span><br><span class="line">  DECLARE t DECIMAL(8,2);</span><br><span class="line">  -- 声明 游标</span><br><span class="line">  DECLARE ordernumbers CURSOR</span><br><span class="line">  FOR</span><br><span class="line">  SELECT order_num FROM orders;</span><br><span class="line">  -- Declare continue handler</span><br><span class="line">  DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1;</span><br><span class="line">  -- 创建一个表用来存储结果</span><br><span class="line">  CREATE TABLE IF NOT EXISTS ordertotals(order_num INT, total DECIMAL(8,2));</span><br><span class="line">  -- Open cursor</span><br><span class="line">  OPEN ordernumbers;</span><br><span class="line">  -- loop through all rows</span><br><span class="line">  REPEAT</span><br><span class="line">    -- Get order number</span><br><span class="line">    FETCH ordernumbers INTO o;</span><br><span class="line">    -- 获取数据</span><br><span class="line">    CALL ordertotal(o, l, t);</span><br><span class="line">    -- 插入数据</span><br><span class="line">    INSERT INTO ordertotals(order_num, total) VALUSE(o, t);</span><br><span class="line">  -- END of loop</span><br><span class="line">  UNTIL done END REPEAT;</span><br><span class="line">  -- Close the cursor</span><br><span class="line">  CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p>
<p>查看结果<code>SELECT * FROM ordertotals;</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/30/MySQL必知必会/第二十二二十三二十四章/" data-id="cjiudwu530002jcvay6tjolnd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL必知必会/">MySQL必知必会</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL必知必会/第十九二十二十一章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/05/MySQL必知必会/第十九二十二十一章/" class="article-date">
  <time datetime="2018-05-05T10:47:00.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/MySQL必知必会/第十九二十二十一章/">MySQL必知必会学习笔记(9)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>INSERT是用来插入(或添加)行到数据库表的。插入可以用几种方式使用：</p>
<ol>
<li>插入完整的行；</li>
<li>插入行的一部分；</li>
<li>插入多行；</li>
<li>插入某些查询的结果</li>
</ol>
<p><strong>插入完整的行：</strong> 要求制定表名和被插入到新行中的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(NULL,</span><br><span class="line">        &apos;Pep E. Lapew&apos;,</span><br><span class="line">        &apos;100 Main Street&apos;,</span><br><span class="line">        &apos;Los Angeles&apos;,</span><br><span class="line">        &apos;CA&apos;,</span><br><span class="line">        &apos;90046&apos;,</span><br><span class="line">        &apos;USA&apos;,</span><br><span class="line">        NULL,</span><br><span class="line">        NULL);</span><br></pre></td></tr></table></figure></p>
<p>你不想给出一个值，又不能省略此列,所以指定一个 NULL 值。</p>
<p>编写INSERT语句的更安全(不过更繁琐)的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">            cust_address,</span><br><span class="line">            cust_state,</span><br><span class="line">            cust_zip,</span><br><span class="line">            cust_country,</span><br><span class="line">            cust_contact,</span><br><span class="line">            cust_email)</span><br><span class="line">        VALUES(&apos;Pep E. Lapew&apos;,</span><br><span class="line">        &apos;100 Main Street&apos;,</span><br><span class="line">        &apos;Los Angeles&apos;,</span><br><span class="line">        &apos;CA&apos;,</span><br><span class="line">        &apos;90046&apos;,</span><br><span class="line">        &apos;USA&apos;,</span><br><span class="line">        NULL,</span><br><span class="line">        NULL);</span><br></pre></td></tr></table></figure></p>
<p>VALUES中第一个值对应于第一个指定的列名。因为提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。</p>
<p><strong>省略列：</strong> 如果表的定义允许，则可以在INSERT操作中省略某些列。</p>
<ol>
<li>该列定义为允许NULL值(无值或空值).</li>
<li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li>
</ol>
<p><strong>提高整体性能：</strong> 数据库经常被多个客户访问，对处理什么请求以及用什么次序处理进行管理是MYSQL的任务，INSERT操作可能很耗时，则我们可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级。(使用UPDATE和DELETE语句)<br><code>INSERT LOW_PROPROTY INTO</code></p>
<h3 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 除了写多个INSERT语句 还能合并写</span><br><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">              cust_address)</span><br><span class="line">        VALUES(&apos;Pep E LaPew&apos;,</span><br><span class="line">                &apos;199 Main Street&apos;),</span><br><span class="line">                (&apos;M, Martian&apos;,</span><br><span class="line">                &apos;242 Galaxy Way&apos;);</span><br></pre></td></tr></table></figure>
<p>此技术可以提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句块。</p>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><p>INSERT还存在另外一种形式，可以利用它将一条SELECT语句的结果插入表中，INSERT SELECT，它是由一条INSERT语句和一条SELECT语句组成的。<br>假如你想从另一表中合并客户列表到你的customers表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_id,cust_name)</span><br><span class="line">SELECT cust_id,cust_name</span><br><span class="line">FROM custnew;</span><br></pre></td></tr></table></figure></p>
<h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新(修改)表中的数据，可使用UPDATE语句。更新特定行，更新表中所有行都行。</p>
<p><strong>不要省略WHERE子句：</strong> 在使用UPDATE时一定要注意细心。稍不注意，会更新表中所有行。</p>
<p>UPDATE语句由三部分组成：</p>
<ol>
<li>要更新的表</li>
<li>列名和它们的新值</li>
<li>确定要更新行的过滤条件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 客户10005现在有了电子邮件地址，因此记录要更新</span><br><span class="line">UPDATE Customers</span><br><span class="line">SET cust_email = &apos;elmer@fudd.com&apos;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># WHERE子句告诉MYSQL更新哪一行</span><br><span class="line">UPDATE customers</span><br><span class="line">SET cust_name = &apos;The Fudds&apos;,</span><br><span class="line">    cust_email = &apos;elmer@fudd.com&apos;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>
<p><strong>在UPDATE语句中使用子查询：</strong> UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。</p>
<p><strong>IGNORE关键字：</strong> 如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出现一个错误，导致整个UPDATE操作取消。为了发生错误时，也继续更新，可使用IGNORE关键字<code>UPDATE IGNORE customers</code>.</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>为了从一个表中删除(去掉)数据，使用DELETE语句。可以删除特定的行或所有行。</p>
<p><strong>不要省略WHERE子句：</strong> 如果稍不注意，就会错误地删除表中所有的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM customers</span><br><span class="line">WHERE cust_id = 10006;</span><br></pre></td></tr></table></figure>
<p>DELETE删除整行而不是删除列。为了删除指定的列，请使用UPDATE语句。</p>
<p><strong>删除表的内容而不是表：</strong> DELETE语句从表中删除行，甚至是删除表中所有行。</p>
<p><strong>更快的删除：</strong> 如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句。它完成相同的工作，但速度更快。(TRYBCATE实际删除原来的表并重新创建一个表，而不是逐行删除)</p>
<h3 id="更新和删除的知道原则"><a href="#更新和删除的知道原则" class="headerlink" title="更新和删除的知道原则"></a>更新和删除的知道原则</h3><p>如果省略了WHERE子句，则UPDATE或DELETE将被应用到表中所有行。</p>
<ol>
<li>除非确实打算更新或删除一行，否则绝不要用不带WHERE子句的UPDATE或DELETE语句。</li>
<li>保证每个表都有主键</li>
<li>在使用UPDATE或DELETE之前，先用SELECT进行测试，过滤正确记录。</li>
<li>使用强制实施引用完整性的数据库，这样MYSQL将不允许删除具有与其他表相关联的数据的行。</li>
</ol>
<p><strong>小心使用：</strong> MYSQL没有撤销(undo)按钮。</p>
<h2 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h2><p>创建表的方法有两种：1.使用工具 2.直接用MySQL语句。<br>利用CREATE TABLE创建表，必须给出下列信息：</p>
<ol>
<li>新表的名字，在关键字CREATE TABLE之后给出；</li>
<li>表列的名字和定义，用逗号分隔；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line">  cust_id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  cust_name char(50) NOT NULL,</span><br><span class="line">  PRIMARY KEY(cust_id)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS。它查看表名是否存在，并且仅在表名不存在时创建它。</p>
<h3 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h3><p>NULL值就是没有值或缺值。允许NULL值得列也允许在插入时不给出该列的值。</p>
<p>不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定。</p>
<h3 id="主键再介绍"><a href="#主键再介绍" class="headerlink" title="主键再介绍"></a>主键再介绍</h3><p>主键值必须唯一。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。<br><code>PRIMARY KEY(order_num, order_item)</code><br>主键唯一标识表中每个行的列。主键中只能使用不允许NULL值得列。允许NULL值得列不能作为唯一标识。</p>
<h3 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h3><p>AUTO_INCREMENT告诉MYSQL，本列每当增加一行时自动增量。每次执行一个INSERT操作，MYSQL自动对该增列增量，给该列赋予下一个可用的值。<br>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引。</p>
<p><code>SELECT last_insert_id()</code>此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续语句。</p>
<h3 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h3><p>如果插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句中的DEFAULT关键字指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE(</span><br><span class="line">      order_num int NOT NULL,</span><br><span class="line">      order_item int NOT NULL,</span><br><span class="line">      quantity int NOT NULL DEFAULT 1,</span><br><span class="line">      PRIMARY KEY(order_num, order_item)</span><br><span class="line">)ENGINE=InnoDB;</span><br></pre></td></tr></table></figure></p>
<p>MySQL不允许使用函数作为默认值，它只支持常量。<br>使用默认值而不是NULL。</p>
<h3 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h3><p>MySQL有一个具体管理和处理数据的内部引擎。在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT语句或进行其他数据库处理时，该引擎在内部处理你的请求。MySQL具有多种引擎，它打包多个引擎，这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT等命令。</p>
<ol>
<li>Innodb是一个可靠的事务处理引擎，它不支持全文本搜索。</li>
<li>MEMORY在功能上等同于MyISAM，但由于数据存储在内存(不是磁盘)中，速度很快(特别适用于临时表)。</li>
<li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。</li>
</ol>
<p>使用一个引擎的表不能引用具有使用不同引擎的表的外键。</p>
<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><p>使用ALTER TABLE语句，1.在ALTER TABLE之后给出要更改的表名(表必须存在)2.所做更改的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 给表添加一个列</span><br><span class="line">ALTER TALBE vendors</span><br><span class="line">ADD vend_phone CHAR(20);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除刚刚添加的列</span><br><span class="line">ALTER TABLE Vendors</span><br><span class="line">DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure>
<p>ALTER TABLE的一种常见用途是定义外键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_orders</span><br><span class="line">FOREGIN KEY(order_item) REFERENCE orders(order_item);</span><br></pre></td></tr></table></figure></p>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>删除表使用DROP TABLE语句。<code>DROP TABLE customer2;</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/05/MySQL必知必会/第十九二十二十一章/" data-id="cjht999h50002acvabrlla4cs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL必知必会/">MySQL必知必会</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL必知必会/第十七十八章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/MySQL必知必会/第十七十八章/" class="article-date">
  <time datetime="2018-04-27T02:35:00.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/MySQL必知必会/第十七十八章/">MySQL必知必会学习笔记(8)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>多数SQL查询只包含从一个或多个表中返回数据的单条SELECT语句。MYSQL也允许执行多个查询(多条SELECT语句)，并将结果作为单个查询结果集返回。这些组合查询通常称为并(union)或复合查询。</p>
<p>两种情况，需要使用组合查询：</p>
<ol>
<li>在单个查询中从不同的表返回类似结构的数据；</li>
<li>对单个表执行多个查询，按单个查询返回数据。</li>
</ol>
<p>多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。因此，两种都要试下，以确定对特定的查询哪一种性能更好。</p>
<p><strong>创建组合查询：</strong> 可用UNION操作符来组合数条SQL查询。利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集。</p>
<p>给出每条SELECT语句，在各条语句之间放上关键字UNION。</p>
<p>示例：需要价格小于等于 5 的所有物品的一个列表，而且还想包括供应商 1001 和 1002 生产的所有物品（不考虑价格）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 1.</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5;</span><br><span class="line"></span><br><span class="line"># 2.</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1001,1002);</span><br><span class="line"></span><br><span class="line"># 组合两条语句</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1001,1002);</span><br></pre></td></tr></table></figure></p>
<p>UNION指示MYSQL执行两条SELECT语句，并把结果组合成单个查询结果集。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-5-3/10105867.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用多条WHERE子句而不使用UNION相同的查询</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5 OR vend_id IN (1001,1002);</span><br></pre></td></tr></table></figure>
<p><strong>UNION规则：</strong></p>
<ol>
<li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分割</li>
<li>UNION的每个查询必须包含相同的列、表达式或聚集函数。</li>
<li>列数据类型必须兼容：类型不必相同，但必须是DBMS可以隐含地转换类型。</li>
</ol>
<p><strong>包含或取消重复行：</strong> UNION从查询结果中自动去除了重复的行。这是UNION的默认行为，但是如果需要它，可以改变它。如果想返回所有匹配的行，可使用UNION ALL而不是UNION。</p>
<p><strong>对组合查询结果排序：</strong> SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。对于结果集，不存在用一种方式排序一部分，用另一种方式排序，因此不允许使用多条ORDER BY子句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1001,1002)</span><br><span class="line">ORDER BY vend_id, prod_price;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-5-3/50459364.jpg" alt=""><br>虽然ORDER BY子句似乎只是最后一条SELECT语句的组成部分，但实际上MySQL将用它来排序所有SELECT语句返回的所有结果。</p>
<p>UNION的组合查询可以应用不同的表。</p>
<h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><p>MySQL支持几种基本的数据库引擎，并非所有的引擎都支持全文本搜索。最常使用的引擎为MyISAM和InnoDB(前者支持全文本搜索，后者不支持)。<br>LIKE关键字，利用通配操作符匹配文本。能够查找包含特殊值或部分值得行。<br>正则表达式，可编写查找所需行的非常复杂的匹配模式。</p>
<p>虽然这些搜索机制很有用，但存在几个重要的限制：性能，明确控制，智能化结果</p>
<ol>
<li>性能：通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行(这些搜索极少使用表索引)，因此，由于被搜索行数不断增加，这些搜索可能非常耗时。</li>
<li>明确控制：使用通配符和正则表达式很难(并不是总能)明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词匹配的情况下才可以匹配或者才可以不匹配。</li>
<li>智能化的结果： 基于通配符和正则表达式的搜索，它们都不能提供一种智能化的选择结果的方法。例如，一个特殊词的搜索会返回包含该词的所有行，而不区分包含单个匹配的行和包含多个匹配的行(按照可能更好的匹配来排列它们)。不会找出不包含该词但包含相关词的行。</li>
</ol>
<p>这些限制可以用全文本搜索，在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理每个词。MySQL创建指定列中各词的一个索引，搜索可以对这些词进行。这样，MySQL可以快速有效的决定哪些词匹配(那些行包含它们，哪些词不匹配，它们的匹配频率等等)</p>
<h3 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h3><p>为了进行全文本搜索，必须索引被搜索的列，而且要随之数据的改变不断地重新索引。对表的适当设计，MySQL会自动进行所有的索引和重新索引。<br>在索引之后，SELECT可与<code>Match()</code>和<code>Against()</code>一起使用以实际执行搜索。</p>
<p>一般在创建表时使用全文本搜索。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">    note_id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">    prod_id char(10) NOT NULL,</span><br><span class="line">    note_date datetime NOT NULL,</span><br><span class="line">    note_text text NULL,</span><br><span class="line">    PRIMARY KEY(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure></p>
<p>MYSQL根据子句FULLTEXT(note_text)的指示对它进行索引。这里的FULLTEXT索引单个列，如果需要也可以指定多个列。<br>在定义后，MYSQL会自动维护该索引。在增加、更新、删除时，索引随之自动更新。</p>
<p><strong>不要再导入数据时使用FULLTEXT：</strong> 更新索引要花时间，先导入完数据，然后修改表，定义FULLTEXT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;rabbit&apos;);</span><br></pre></td></tr></table></figure>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-5-4/21099563.jpg" alt=""><br>Match(note_text) 指示MySQL针对指定的列进行搜索， Against(‘rabbit’) 指定词 rabbit 作为搜索文本.</p>
<p>使用完整的Match()说明：传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出他们(次序要正确)。</p>
<p>除非使用BINARY方式，否则全文本搜索不区分大小写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用LIKE可以完成同上的功能</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE note_text LIKE &apos;%rabbit%&apos;;</span><br></pre></td></tr></table></figure></p>
<p>这条 SELECT 语句同样检索出两行，但次序不同。</p>
<p>上面两条SELECT语句都不包含ORDER BY子句。(使用LIKE)会以不特别有用的顺序返回数据。(使用全文本搜索)返回以文本匹配的良好程度排序的数据。全文本搜索一个重要部分就是对结果排序。具有较高优先级的行先返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text, Match(note_text) Against(&apos;rabbit&apos;) AS rank</span><br><span class="line">FROM productnotes;</span><br></pre></td></tr></table></figure>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-5-4/7723783.jpg" alt=""><br>不包含词 rabbit 的行等级为0,包含rabbit的两行每行都有一个等级值，文本中词靠前的行的等级值比词靠后的行的等级值高。</p>
<p>排序多个索引项，匹配词多的行等级值高于匹配词少的行。全文本搜索由于数据是索引的，比LIKE搜索快。</p>
<h3 id="使用查询扩展（适用于4-1-1之后版本）"><a href="#使用查询扩展（适用于4-1-1之后版本）" class="headerlink" title="使用查询扩展（适用于4.1.1之后版本）"></a>使用查询扩展（适用于4.1.1之后版本）</h3><p>查询扩展用来设法放宽返回的全文本搜索结果的范围。<br>如果你想找出所有提到 anvils 的注释。只有一个注释包含词 anvils ，但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils 。<br>这也是查询扩展的一项任务，在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索：<br>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；<br>其次，MySQL检查这些匹配行并选择所有有用的词。<br>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还是用所有有用的词。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这是没有查询扩展的例子</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;anvils&apos;);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-5-5/88149461.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用了查询扩展</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;anvils&apos; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-5-5/19857906.jpg" alt=""><br>第一行包含词anvils，因此等级高，第二行与anvils无关，但它包含第一行中的两个词(customer和recommend),因此被检索出来。第三行，包含这两个相同的词，但在文本位置靠后且分开得更远，所以等级3.</p>
<h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><p>MySQL支持全文本搜索的另外一种形式，称为布尔方式。以布尔方式，可提供关于如下内容的细节：<br>要匹配的词、要排斥的词、排列提示、表达式分组。<br>没有定义FULLTEXT索引也可以使用它，但速度很慢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># IN BOOLEAN MODE的作用</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;heavy&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-5-5/53959579.jpg" alt=""><br>此全文本搜索检索包含词 heavy 的所有行（有两行）。使用了关键字 IN BOOLEAN MODE ，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同。</p>
<p>为了匹配包含heavy但不包含任意以rope开始的词的行，可使用一下查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;heavy -rope*&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://oqp1ywek9.bkt.clouddn.com/18-5-5/77841923.jpg" alt=""><br>这次只返回一行。这一次仍然匹配词 heavy ，但 -rope<em> 明确地指示MySQL排除包含 rope</em>(任何以 rope 开始的词，包括ropes)的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;+rabbit +bait&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<p>搜索匹配包含词rabbit和bait的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;rabbit bait&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<p>搜索匹配包含rabbit和bait中的至少一个词的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;&quot;rabbit bait&quot;&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<p>搜索匹配短语rabbit bait而不是匹配两个词rabbit和bait。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;&gt;rabbit &lt;carrot&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<p>匹配rabbit和carrot，增加前者的等级，降低后者的等级。</p>
<p>在索引全文本数据时，短词被忽略且从索引中排除。(短词：3个或3个以下字符的词)</p>
<p>MYSQL规定，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。(MySQL带有一个内建的非用词)</p>
<p>忽略词的单引号。例如don’t索引为dont。</p>
<p>仅在MyISAM数据库引擎中支持全文本搜索。</p>
<p>MYSQL全文本搜索不支持邻近操作符。(他能搜索相邻的词)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/MySQL必知必会/第十七十八章/" data-id="cjgryx1yc0000dova30iue88t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL必知必会/">MySQL必知必会</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL必知必会/第十五十六章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/25/MySQL必知必会/第十五十六章/" class="article-date">
  <time datetime="2018-04-25T14:50:00.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/MySQL必知必会/第十五十六章/">MySQL必知必会学习笔记(7)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><p>联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结及其语法是SQL的一个极为重要的组成部分。</p>
<p>外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p>
<p>关系数据可以有效地存储和方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。</p>
<p><strong>可伸缩性：</strong> 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好。</p>
<p>为什么要使用联结？<br>分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但是有代价的，如果数据存储在多个表中，怎么样用单条SELECT语句检索出数据？<br>使用联结！使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。<br>联结由MySQL根据需要建立，它存在于查询的执行当中。</p>
<p><strong>创建联结</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors, products</span><br><span class="line">WHERE vendors.vend_id = products.vend_id</span><br><span class="line">ORDER BY vend_name, prod_name;</span><br></pre></td></tr></table></figure></p>
<p>FROM语句列出两个表，分别是vendors,products。这两个表用WHERE子句正确联结，WHERE子句指示MYSQL匹配vendors表中的vend_id和表中的vend_id.（vendors.vend_id = products.vend_id）<br>这里需要这种完全限定列名，因为如果只给出 vend_id ，则MySQL不知道指的是哪一个。<br><img src="http://oqp1ywek9.bkt.clouddn.com/18-4-26/8885408.jpg" alt=""></p>
<p>在一条 SELECT 语句中联结几个表时，相应的关系是在运行中构造的。WHERE子句作为过滤条件，它只包含那些匹配给定条件的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管他们逻辑上是否可以配在一起。</p>
<p><strong>笛卡尔积：</strong> 没有联结条件的的表关系返回结果为笛卡尔积。检索出的行的数目将是将是第一个表中的行数乘以第二个表中的行数。</p>
<p><strong>不要忘了WHERE子句：</strong> 应该保证所有联结都有WHERE子句，否则MYSQL将返回很多数据。并且保证WHERE子句的正确性。</p>
<p><strong>内部联结（内连接）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line">ON vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure></p>
<p>这个与上面的语句结果相同，FROM子句不同。两表之间关系以INNER JOIN指定。使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</p>
<p>两种语法结果都相同，但要优先使用INNER JOIN 语法哦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 联结多个表</span><br><span class="line">SELECT prod_name, vend_name, prod_price, quantity</span><br><span class="line">FROM orderitems, products, vendors</span><br><span class="line">WHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 20005;</span><br></pre></td></tr></table></figure>
<p>MYSQL在运行时关联指定的每个表以处理联结。这种处理非常消耗资源。联结的表越多，性能下降的越厉害。</p>
<h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><p><strong>别名：</strong> 别名除了用于列名和计算字段外，SQL还允许给表名起别名。理由：1.缩短SQL语句。2.允许在单条SELECT语句中多次使用相同的表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers AS c, orders AS o, orderitems  AS oi</span><br><span class="line">WHERE c.cust_id = o.cust_id  AND oi.order_num = o.order_num AND prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<p>表别名不仅能用于WHERE子句，还可以用于SELECT的列表、ORDER BY子句以及语句的其他部分。</p>
<p>用自联结而不用子查询：子联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。 虽然最终结果是相同的，但有时候处理联结远比处理子查询快的多。应该都试一下。</p>
<p>自然连接：<br>自然连接是一种特殊的等值连接，他要求两个关系表中进行比较的必须是相同的属性列，无须添加连接条件，并且在结果中消除重复的属性列。</p>
<p><strong>外部连接：</strong> 连接包含了那些在相关表中没有关联行的行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id, orders.order_num</span><br><span class="line">FROM customers LEFT OUTER JOIN orders</span><br><span class="line">ON customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure></p>
<p>SELECT 语句使用了关键字 OUTER JOIN 来指定联结的类型。与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。为了从右边的表中选择所<br>有行，应该使用 RIGHT OUTER JOIN。</p>
<p>外部连接的基本类型:存在两种基本的外部连接形式(左外部连接和右外部连接)。之间唯一差别是表的顺序不同。</p>
<p>使用聚集函数的连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># COUNT(column) 会忽略 NULL 所以会出现技数为0</span><br><span class="line">SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ord</span><br><span class="line">FROM customers LEFT OUTER JOIN orders</span><br><span class="line">ON customers.cust_id = orders.cust_id</span><br><span class="line">GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用连接和连接条件</strong></p>
<ol>
<li>注意所使用的连接类型。一般我们使用内部连接，但使用外部连接也是有效。</li>
<li>保证使用正确的连接条件，否则将返回不正确的数据。</li>
<li>应该总是提供连接条件，否则会得出笛卡尔积。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/25/MySQL必知必会/第十五十六章/" data-id="cjgryx1ym0005dovasjiez15r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL必知必会/">MySQL必知必会</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java多线程/">Java多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx学习笔记/">Nginx学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python基础/">Python基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习成长/">学习成长</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL必知必会/">MySQL必知必会</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL技术内幕/">MySQL技术内幕</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/MySQL必知必会/" style="font-size: 20px;">MySQL必知必会</a> <a href="/tags/MySQL技术内幕/" style="font-size: 10px;">MySQL技术内幕</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/19/MySQL技术内幕/第四章/">第三章 表 读书笔记</a>
          </li>
        
          <li>
            <a href="/2018/07/19/MySQL技术内幕/第三章/">第三章 文件 读书笔记</a>
          </li>
        
          <li>
            <a href="/2018/06/26/MySQL技术内幕/第二章/">第二章 Innodb存储引擎 读书笔记</a>
          </li>
        
          <li>
            <a href="/2018/06/26/MySQL技术内幕/第五章/">第五章 索引与算法 读书笔记</a>
          </li>
        
          <li>
            <a href="/2018/06/25/MySQL技术内幕/第一章/">第一章 MySQL体系结构和存储引擎 读书笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 殷鑫<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>